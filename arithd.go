// Code generated by scripts/arithd.pl. DO NOT EDIT.

package goal

import (
	"math"
	"strings"
)

// equal returns x=y.
func equal(x, y V) V {
	if x.IsI() {
		return equalIV(x.I(), y)
	}
	if x.IsF() {
		return equalFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return equalSV(xv, y)
	case *AB:
		return equalABV(xv, y)
	case *AF:
		return equalAFV(xv, y)
	case *AI:
		return equalAIV(xv, y)
	case *AS:
		return equalASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x=y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := equal(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := equal(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "x", x)
	}
}

func equalFV(x float64, y V) V {
	if y.IsI() {
		return NewI(b2i(x == float64(y.I())))
	}
	if y.IsF() {
		return NewI(b2i(x == y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x == b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x == yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x == float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := equalFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalIV(x int64, y V) V {
	if y.IsI() {
		return NewI(b2i(x == y.I()))
	}
	if y.IsF() {
		return NewI(b2i(float64(x) == y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x == b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x) == yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x == yv.At(i))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := equalIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewI(int64(b2i(S(x) == S(yv))))
	case *AS:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x) == S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := equalSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) == int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) == float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) == yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) == yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) == yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := equalIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalAFV(x *AF, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) == float64(int64(y.I())))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) == float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) == b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) == yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) == float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := equalFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalAIV(x *AI, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) == int64(y.I()))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) == float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) == b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) == yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) == yv.At(i))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := equalIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

func equalASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) == S(yv))
		}
		return NewAB(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) == S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x=y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := equalSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x=y", "y", y)
	}
}

// lesser returns x<y.
func lesser(x, y V) V {
	if x.IsI() {
		return lesserIV(x.I(), y)
	}
	if x.IsF() {
		return lesserFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return lesserSV(xv, y)
	case *AB:
		return lesserABV(xv, y)
	case *AF:
		return lesserAFV(xv, y)
	case *AI:
		return lesserAIV(xv, y)
	case *AS:
		return lesserASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x<y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := lesser(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := lesser(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "x", x)
	}
}

func lesserFV(x float64, y V) V {
	if y.IsI() {
		return NewI(b2i(x < float64(y.I())))
	}
	if y.IsF() {
		return NewI(b2i(x < y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x < b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x < yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x < float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := lesserFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserIV(x int64, y V) V {
	if y.IsI() {
		return NewI(b2i(x < y.I()))
	}
	if y.IsF() {
		return NewI(b2i(float64(x) < y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x < b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x) < yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x < yv.At(i))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := lesserIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewI(int64(b2i(S(x) < S(yv))))
	case *AS:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x) < S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := lesserSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) < int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) < float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(!x.At(i) && yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) < yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) < yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := lesserIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserAFV(x *AF, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) < float64(int64(y.I())))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) < float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) < b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) < yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) < float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := lesserFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserAIV(x *AI, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) < int64(y.I()))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) < float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) < b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) < yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) < yv.At(i))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := lesserIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

func lesserASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) < S(yv))
		}
		return NewAB(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) < S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x<y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := lesserSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x<y", "y", y)
	}
}

// greater returns x>y.
func greater(x, y V) V {
	if x.IsI() {
		return greaterIV(x.I(), y)
	}
	if x.IsF() {
		return greaterFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return greaterSV(xv, y)
	case *AB:
		return greaterABV(xv, y)
	case *AF:
		return greaterAFV(xv, y)
	case *AI:
		return greaterAIV(xv, y)
	case *AS:
		return greaterASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x>y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := greater(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := greater(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "x", x)
	}
}

func greaterFV(x float64, y V) V {
	if y.IsI() {
		return NewI(b2i(x > float64(y.I())))
	}
	if y.IsF() {
		return NewI(b2i(x > y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x > b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x > yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x > float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := greaterFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterIV(x int64, y V) V {
	if y.IsI() {
		return NewI(b2i(x > y.I()))
	}
	if y.IsF() {
		return NewI(b2i(float64(x) > y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x > b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x) > yv.At(i))
		}
		return NewAB(r)
	case *AI:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x > yv.At(i))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := greaterIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewI(int64(b2i(S(x) > S(yv))))
	case *AS:
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x) > S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := greaterSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) > int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) > float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) && !yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2f(x.At(i)) > yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(b2i(x.At(i)) > yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := greaterIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterAFV(x *AF, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) > float64(int64(y.I())))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) > float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) > b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) > yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) > float64(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := greaterFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterAIV(x *AI, y V) V {
	if y.IsI() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(x.At(i) > int64(y.I()))
		}
		return NewAB(r)
	}
	if y.IsF() {
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) > float64(y.F()))
		}
		return NewAB(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) > b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(float64(x.At(i)) > yv.At(i))
		}
		return NewAB(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(x.At(i) > yv.At(i))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := greaterIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

func greaterASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := make([]bool, x.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) > S(yv))
		}
		return NewAB(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]bool, yv.Len())
		for i := range r {
			r[i] = bool(S(x.At(i)) > S(yv.At(i)))
		}
		return NewAB(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x>y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := greaterSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x>y", "y", y)
	}
}

// add returns x+y.
func add(x, y V) V {
	if x.IsI() {
		return addIV(x.I(), y)
	}
	if x.IsF() {
		return addFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return addSV(xv, y)
	case *AB:
		return addABV(xv, y)
	case *AF:
		return addAFV(xv, y)
	case *AI:
		return addAIV(xv, y)
	case *AS:
		return addASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x+y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := add(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := add(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "x", x)
	}
}

func addFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x + float64(y.I()))
	}
	if y.IsF() {
		return NewF(x + y.F())
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x + b2f(yv.At(i)))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x + yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x + float64(yv.At(i)))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := addFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x + y.I())
	}
	if y.IsF() {
		return NewF(float64(x) + y.F())
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(x + b2i(yv.At(i)))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x + yv.At(i))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := addIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewV(S(S(x) + S(yv)))
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(S(x) + S(yv.At(i)))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := addSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(b2i(x.At(i)) + int64(y.I()))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(b2f(x.At(i)) + float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(b2i(x.At(i)) + b2i(yv.At(i)))
		}
		return NewAI(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(b2f(x.At(i)) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(b2i(x.At(i)) + yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := addIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) + float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) + float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) + b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) + float64(yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := addFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) + int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(float64(x.At(i)) + float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) + b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x.At(i)) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) + yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := addIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

func addASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(S(x.At(i)) + S(yv))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(S(x.At(i)) + S(yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x+y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := addSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x+y", "y", y)
	}
}

// subtract returns x-y.
func subtract(x, y V) V {
	if x.IsI() {
		return subtractIV(x.I(), y)
	}
	if x.IsF() {
		return subtractFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return subtractSV(xv, y)
	case *AB:
		return subtractABV(xv, y)
	case *AF:
		return subtractAFV(xv, y)
	case *AI:
		return subtractAIV(xv, y)
	case *AS:
		return subtractASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x-y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := subtract(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := subtract(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "x", x)
	}
}

func subtractFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x - float64(y.I()))
	}
	if y.IsF() {
		return NewF(x - y.F())
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x - b2f(yv.At(i)))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x - yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x - float64(yv.At(i)))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := subtractFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x - y.I())
	}
	if y.IsF() {
		return NewF(float64(x) - y.F())
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(x - b2i(yv.At(i)))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x - yv.At(i))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := subtractIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewV(S(strings.TrimSuffix(string(S(x)), string(S(yv)))))
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.TrimSuffix(string(S(x)), string(S(yv.At(i)))))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := subtractSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(b2i(x.At(i)) - int64(y.I()))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(b2f(x.At(i)) - float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(b2i(x.At(i)) - b2i(yv.At(i)))
		}
		return NewAI(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(b2f(x.At(i)) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(b2i(x.At(i)) - yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := subtractIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) - float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) - float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) - b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) - float64(yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := subtractFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) - int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(float64(x.At(i)) - float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) - b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x.At(i)) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) - yv.At(i))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := subtractIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

func subtractASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.TrimSuffix(string(S(x.At(i))), string(S(yv))))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.TrimSuffix(string(S(x.At(i))), string(S(yv.At(i)))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x-y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := subtractSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x-y", "y", y)
	}
}

// multiply returns x*y.
func multiply(x, y V) V {
	if x.IsI() {
		return multiplyIV(x.I(), y)
	}
	if x.IsF() {
		return multiplyFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return multiplySV(xv, y)
	case *AB:
		return multiplyABV(xv, y)
	case *AF:
		return multiplyAFV(xv, y)
	case *AI:
		return multiplyAIV(xv, y)
	case *AS:
		return multiplyASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x*y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := multiply(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := multiply(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "x", x)
	}
}

func multiplyFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x * float64(y.I()))
	}
	if y.IsF() {
		return NewF(x * y.F())
	}
	switch yv := y.value.(type) {
	case S:
		return NewV(S(strings.Repeat(string(S(yv)), int(float64(x)))))
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x * b2f(yv.At(i)))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x * yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(x * float64(yv.At(i)))
		}
		return NewAF(r)
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(yv.At(i))), int(float64(x))))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := multiplyFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplyIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x * y.I())
	}
	if y.IsF() {
		return NewF(float64(x) * y.F())
	}
	switch yv := y.value.(type) {
	case S:
		return NewV(S(strings.Repeat(string(S(yv)), int(x))))
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(x * b2i(yv.At(i)))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x * yv.At(i))
		}
		return NewV(r)
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(yv.At(i))), int(x)))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := multiplyIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplySV(x S, y V) V {
	if y.IsI() {
		return NewV(S(strings.Repeat(string(x), int(y.I()))))
	}
	if y.IsF() {
		return NewV(S(strings.Repeat(string(x), int(float64(y.F())))))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]string, yv.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(b2i(yv.At(i)))))
		}
		return NewAS(r)
	case *AF:
		r := make([]string, yv.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(float64(yv.At(i)))))
		}
		return NewAS(r)
	case *AI:
		r := make([]string, yv.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(x)), int(yv.At(i))))
		}
		return NewAS(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := multiplySV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplyABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(b2i(x.At(i)) * int64(y.I()))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(b2f(x.At(i)) * float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case S:
		r := make([]string, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(yv)), int(b2i(x.At(i)))))
		}
		return NewAS(r)
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) && yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(b2f(x.At(i)) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(b2i(x.At(i)) * yv.At(i))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(yv.At(i))), int(b2i(x.At(i)))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := multiplyIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplyAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) * float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) * float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case S:
		r := make([]string, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(yv)), int(float64(x.At(i)))))
		}
		return NewAS(r)
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) * b2f(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(x.At(i) * float64(yv.At(i)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(yv.At(i))), int(float64(x.At(i)))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := multiplyFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplyAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) * int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(float64(x.At(i)) * float64(y.F()))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case S:
		r := make([]string, x.Len())
		for i := range r {
			r[i] = string(strings.Repeat(string(S(yv)), int(x.At(i))))
		}
		return NewAS(r)
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) * b2i(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(float64(x.At(i)) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(x.At(i) * yv.At(i))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(yv.At(i))), int(x.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := multiplyIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

func multiplyASV(x *AS, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(x.At(i))), int(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(x.At(i))), int(float64(float64(y.F())))))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(x.At(i))), int(b2i(yv.At(i)))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(x.At(i))), int(float64(yv.At(i)))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(strings.Repeat(string(S(x.At(i))), int(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x*y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := multiplySV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x*y", "y", y)
	}
}

// divide returns x%y.
func divide(x, y V) V {
	if x.IsI() {
		return divideIV(x.I(), y)
	}
	if x.IsF() {
		return divideFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case *AB:
		return divideABV(xv, y)
	case *AF:
		return divideAFV(xv, y)
	case *AI:
		return divideAIV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x%%y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := divide(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := divide(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "x", x)
	}
}

func divideFV(x float64, y V) V {
	if y.IsI() {
		return NewF(divideF(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(divideF(x, y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(x, b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x, yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(x, float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := divideFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "y", y)
	}
}

func divideIV(x int64, y V) V {
	if y.IsI() {
		return NewF(divideF(float64(x), float64(y.I())))
	}
	if y.IsF() {
		return NewF(divideF(float64(x), y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x), b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(float64(x), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x), float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := divideIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "y", y)
	}
}

func divideABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(divideF(b2f(x.At(i)), float64(int64(y.I()))))
		}
		return NewAF(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(divideF(b2f(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(b2f(x.At(i)), b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(b2f(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(b2f(x.At(i)), float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := divideIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "y", y)
	}
}

func divideAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x.At(i), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x.At(i), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x.At(i), b2f(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x.At(i), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := divideFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "y", y)
	}
}

func divideAIV(x *AI, y V) V {
	if y.IsI() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x.At(i)), float64(int64(y.I()))))
		}
		return NewAF(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x.At(i)), b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(divideF(float64(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(divideF(float64(x.At(i)), float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x%%y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := divideIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x%%y", "y", y)
	}
}

// minimum returns x&y.
func minimum(x, y V) V {
	if x.IsI() {
		return minimumIV(x.I(), y)
	}
	if x.IsF() {
		return minimumFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return minimumSV(xv, y)
	case *AB:
		return minimumABV(xv, y)
	case *AF:
		return minimumAFV(xv, y)
	case *AI:
		return minimumAIV(xv, y)
	case *AS:
		return minimumASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x&y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := minimum(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := minimum(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "x", x)
	}
}

func minimumFV(x float64, y V) V {
	if y.IsI() {
		return NewF(math.Min(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(math.Min(x, float64(y.F())))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(math.Min(x, b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x, float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(math.Min(x, float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := minimumFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumIV(x int64, y V) V {
	if y.IsI() {
		return NewI(minI(x, y.I()))
	}
	if y.IsF() {
		return NewF(math.Min(float64(x), y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(minI(x, b2i(yv.At(i))))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(float64(x), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(minI(x, yv.At(i)))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := minimumIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewV(S(minS(S(x), S(yv))))
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(minS(S(x), S(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := minimumSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(minI(b2i(x.At(i)), int64(y.I())))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(math.Min(b2f(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) && yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(b2f(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(minI(b2i(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := minimumIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x.At(i), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x.At(i), float64(float64(y.F()))))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x.At(i), b2f(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := minimumFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(minI(x.At(i), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(math.Min(float64(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(minI(x.At(i), b2i(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Min(float64(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(minI(x.At(i), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := minimumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

func minimumASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(minS(S(x.At(i)), S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(minS(S(x.At(i)), S(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x&y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := minimumSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x&y", "y", y)
	}
}

// maximum returns x|y.
func maximum(x, y V) V {
	if x.IsI() {
		return maximumIV(x.I(), y)
	}
	if x.IsF() {
		return maximumFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case S:
		return maximumSV(xv, y)
	case *AB:
		return maximumABV(xv, y)
	case *AF:
		return maximumAFV(xv, y)
	case *AI:
		return maximumAIV(xv, y)
	case *AS:
		return maximumASV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x|y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := maximum(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := maximum(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "x", x)
	}
}

func maximumFV(x float64, y V) V {
	if y.IsI() {
		return NewF(math.Max(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(math.Max(x, float64(y.F())))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(math.Max(x, b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x, float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(math.Max(x, float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := maximumFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumIV(x int64, y V) V {
	if y.IsI() {
		return NewI(maxI(x, y.I()))
	}
	if y.IsF() {
		return NewF(math.Max(float64(x), y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(maxI(x, b2i(yv.At(i))))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(float64(x), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(maxI(x, yv.At(i)))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := maximumIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumSV(x S, y V) V {
	switch yv := y.value.(type) {
	case S:
		return NewV(S(maxS(S(x), S(yv))))
	case *AS:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(maxS(S(x), S(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := maximumSV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(maxI(b2i(x.At(i)), int64(y.I())))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(math.Max(b2f(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = bool(x.At(i) || yv.At(i))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(b2f(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(maxI(b2i(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := maximumIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x.At(i), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x.At(i), float64(float64(y.F()))))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x.At(i), b2f(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := maximumFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(maxI(x.At(i), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(math.Max(float64(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(maxI(x.At(i), b2i(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(math.Max(float64(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(maxI(x.At(i), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := maximumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

func maximumASV(x *AS, y V) V {
	switch yv := y.value.(type) {
	case S:
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(maxS(S(x.At(i)), S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = string(maxS(S(x.At(i)), S(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x|y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := maximumSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x|y", "y", y)
	}
}

// modulus returns x mod y.
func modulus(x, y V) V {
	if x.IsI() {
		return modulusIV(x.I(), y)
	}
	if x.IsF() {
		return modulusFV(x.F(), y)
	}
	switch xv := x.value.(type) {
	case *AB:
		return modulusABV(xv, y)
	case *AF:
		return modulusAFV(xv, y)
	case *AI:
		return modulusAIV(xv, y)
	case *AV:
		switch yv := y.value.(type) {
		case array:
			if yv.Len() != xv.Len() {
				return Panicf("x mod y : length mismatch: %d vs %d", xv.Len(), yv.Len())
			}
			r := xv.reuse()
			for i, xi := range xv.Slice {
				ri := modulus(xi, yv.at(i))
				if ri.IsPanic() {
					return ri
				}
				r.Slice[i] = ri
			}
			return NewV(r)
		}
		r := xv.reuse()
		for i, xi := range xv.Slice {
			ri := modulus(xi, y)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "x", x)
	}
}

func modulusFV(x float64, y V) V {
	if y.IsI() {
		return NewF(modF(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(modF(x, y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(modF(x, b2f(yv.At(i))))
		}
		return NewAF(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x, yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := make([]float64, yv.Len())
		for i := range r {
			r[i] = float64(modF(x, float64(yv.At(i))))
		}
		return NewAF(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := modulusFV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "y", y)
	}
}

func modulusIV(x int64, y V) V {
	if y.IsI() {
		return NewI(modI(x, y.I()))
	}
	if y.IsF() {
		return NewF(modF(float64(x), y.F()))
	}
	switch yv := y.value.(type) {
	case *AB:
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(modI(x, b2i(yv.At(i))))
		}
		return NewAI(r)
	case *AF:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(float64(x), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(modI(x, yv.At(i)))
		}
		return NewV(r)
	case *AV:
		r := yv.reuse()
		for i, yi := range yv.Slice {
			ri := modulusIV(x, yi)
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "y", y)
	}
}

func modulusABV(x *AB, y V) V {
	if y.IsI() {
		r := make([]int64, x.Len())
		for i := range r {
			r[i] = int64(modI(b2i(x.At(i)), int64(y.I())))
		}
		return NewAI(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(modF(b2f(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := make([]int64, yv.Len())
		for i := range r {
			r[i] = int64(modI(b2i(x.At(i)), b2i(yv.At(i))))
		}
		return NewAI(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(b2f(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(modI(b2i(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := modulusIV(b2i(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "y", y)
	}
}

func modulusAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x.At(i), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x.At(i), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x.At(i), b2f(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x.At(i), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(x.At(i), float64(yv.At(i))))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := modulusFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "y", y)
	}
}

func modulusAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(modI(x.At(i), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := make([]float64, x.Len())
		for i := range r {
			r[i] = float64(modF(float64(x.At(i)), float64(y.F())))
		}
		return NewAF(r)
	}
	switch yv := y.value.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(modI(x.At(i), b2i(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.Slice {
			r.Slice[i] = float64(modF(float64(x.At(i)), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i := range r.Slice {
			r.Slice[i] = int64(modI(x.At(i), yv.At(i)))
		}
		return NewV(r)
	case *AV:
		if x.Len() != yv.Len() {
			return Panicf("x mod y : length mismatch: %d vs %d", x.Len(), yv.Len())
		}
		r := yv.reuse()

		for i := range r.Slice {
			ri := modulusIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			r.Slice[i] = ri
		}
		return NewV(r)
	default:
		return panicTypeElt("x mod y", "y", y)
	}
}

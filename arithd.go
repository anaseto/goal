// Code generated by scripts/arithd.goal. DO NOT EDIT.

package goal

import (
	"math"
	"strings"
)

// equal returns x=y.
func equal(x, y V) V {
	if x.IsI() {
		return equalIV(x.I(), y)
	}
	if x.IsF() {
		return equalFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return equalSV(xv, y)
	case *AB:
		return equalABV(xv, y)
	case *AF:
		return equalAFV(xv, y)
	case *AI:
		return equalAIV(xv, y)
	case *AS:
		return equalASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, equal(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x=y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, equal)
		}
		return mapAVV(xv, y, equal)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, equal)
			if r.IsPanic() {
				return ppanic("d=d", r)
			}
			return r
		}
		return newDictValues(xv.keys, equal(NewV(xv.values), y))
	default:
		return panicType("x=y", "x", x)
	}
}

func equalFV(x float64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x == float64(y.I()))))
	}
	if y.IsF() {
		return NewI(int64(b2B(x == y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x == float64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x == yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x == float64(yi)))
		}
		return NewV(r)
	case *D:
		v := equalFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return equalFV(x, yi) })
	default:
		return panicType("x=y", "y", y)
	}
}

func equalIV(x int64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x == y.I())))
	}
	if y.IsF() {
		return NewI(int64(b2B(float64(x) == y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x == int64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(float64(x) == yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x == yi))
		}
		return NewV(r)
	case *D:
		v := equalIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return equalIV(x, yi) })
	default:
		return panicType("x=y", "y", y)
	}
}

func equalSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewI(int64(int64(b2B(S(x) == S(yv)))))
	case *AS:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(S(x) == S(yi)))
		}
		return NewV(r)
	case *D:
		v := equalSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return equalSV(x, yi) })
	default:
		return panicType("x=y", "y", y)
	}
}

func equalABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) == int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) == float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) == yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) == yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := equalABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := equalIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x=y", "y", y)
	}
}

func equalAFV(x *AF, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := equalAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := equalFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x=y", "y", y)
	}
}

func equalAIV(x *AI, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) == float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) == yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi == yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := equalAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := equalIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x=y", "y", y)
	}
}

func equalASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i := range r.elts {
			r.elts[i] = byte(b2B(S(x.At(i)) == S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(S(xi) == S(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := equalASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x=y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := equalSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x=y", "y", y)
	}
}

// less returns x<y.
func less(x, y V) V {
	if x.IsI() {
		return lessIV(x.I(), y)
	}
	if x.IsF() {
		return lessFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return lessSV(xv, y)
	case *AB:
		return lessABV(xv, y)
	case *AF:
		return lessAFV(xv, y)
	case *AI:
		return lessAIV(xv, y)
	case *AS:
		return lessASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, less(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x<y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, less)
		}
		return mapAVV(xv, y, less)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, less)
			if r.IsPanic() {
				return ppanic("d<d", r)
			}
			return r
		}
		return newDictValues(xv.keys, less(NewV(xv.values), y))
	default:
		return panicType("x<y", "x", x)
	}
}

func lessFV(x float64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x < float64(y.I()))))
	}
	if y.IsF() {
		return NewI(int64(b2B(x < y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x < float64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x < yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x < float64(yi)))
		}
		return NewV(r)
	case *D:
		v := lessFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return lessFV(x, yi) })
	default:
		return panicType("x<y", "y", y)
	}
}

func lessIV(x int64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x < y.I())))
	}
	if y.IsF() {
		return NewI(int64(b2B(float64(x) < y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x < int64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(float64(x) < yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x < yi))
		}
		return NewV(r)
	case *D:
		v := lessIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return lessIV(x, yi) })
	default:
		return panicType("x<y", "y", y)
	}
}

func lessSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewI(int64(int64(b2B(S(x) < S(yv)))))
	case *AS:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(S(x) < S(yi)))
		}
		return NewV(r)
	case *D:
		v := lessSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return lessSV(x, yi) })
	default:
		return panicType("x<y", "y", y)
	}
}

func lessABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) < int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) < float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) < yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) < yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := lessABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := lessIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x<y", "y", y)
	}
}

func lessAFV(x *AF, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := lessAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := lessFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x<y", "y", y)
	}
}

func lessAIV(x *AI, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) < float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) < yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi < yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := lessAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := lessIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x<y", "y", y)
	}
}

func lessASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i := range r.elts {
			r.elts[i] = byte(b2B(S(x.At(i)) < S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(S(xi) < S(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := lessASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x<y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := lessSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x<y", "y", y)
	}
}

// more returns x>y.
func more(x, y V) V {
	if x.IsI() {
		return moreIV(x.I(), y)
	}
	if x.IsF() {
		return moreFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return moreSV(xv, y)
	case *AB:
		return moreABV(xv, y)
	case *AF:
		return moreAFV(xv, y)
	case *AI:
		return moreAIV(xv, y)
	case *AS:
		return moreASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, more(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x>y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, more)
		}
		return mapAVV(xv, y, more)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, more)
			if r.IsPanic() {
				return ppanic("d>d", r)
			}
			return r
		}
		return newDictValues(xv.keys, more(NewV(xv.values), y))
	default:
		return panicType("x>y", "x", x)
	}
}

func moreFV(x float64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x > float64(y.I()))))
	}
	if y.IsF() {
		return NewI(int64(b2B(x > y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x > float64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x > yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x > float64(yi)))
		}
		return NewV(r)
	case *D:
		v := moreFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return moreFV(x, yi) })
	default:
		return panicType("x>y", "y", y)
	}
}

func moreIV(x int64, y V) V {
	if y.IsI() {
		return NewI(int64(b2B(x > y.I())))
	}
	if y.IsF() {
		return NewI(int64(b2B(float64(x) > y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := yv.reuse()
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x > int64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(float64(x) > yi))
		}
		return NewV(r)
	case *AI:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(x > yi))
		}
		return NewV(r)
	case *D:
		v := moreIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return moreIV(x, yi) })
	default:
		return panicType("x>y", "y", y)
	}
}

func moreSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewI(int64(int64(b2B(S(x) > S(yv)))))
	case *AS:
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, yi := range yv.elts {
			r.elts[i] = byte(b2B(S(x) > S(yi)))
		}
		return NewV(r)
	case *D:
		v := moreSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return moreSV(x, yi) })
	default:
		return panicType("x>y", "y", y)
	}
}

func moreABV(x *AB, y V) V {
	if y.IsI() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) > int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) > float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) > yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := x.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(int64(xi) > yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := moreABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := moreIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x>y", "y", y)
	}
}

func moreAFV(x *AF, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := moreAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := moreFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x>y", "y", y)
	}
}

func moreAIV(x *AI, y V) V {
	if y.IsI() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) > float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(float64(xi) > yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(xi > yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := moreAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := moreIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x>y", "y", y)
	}
}

func moreASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := &AB{elts: make([]byte, x.Len())}
		r.flags |= flagBool
		for i := range r.elts {
			r.elts[i] = byte(b2B(S(x.At(i)) > S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := &AB{elts: make([]byte, yv.Len())}
		r.flags |= flagBool
		for i, xi := range x.elts {
			r.elts[i] = byte(b2B(S(xi) > S(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := moreASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x>y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := moreSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x>y", "y", y)
	}
}

// add returns x+y.
func add(x, y V) V {
	if x.IsI() {
		return addIV(x.I(), y)
	}
	if x.IsF() {
		return addFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return addSV(xv, y)
	case *AB:
		return addABV(xv, y)
	case *AF:
		return addAFV(xv, y)
	case *AI:
		return addAIV(xv, y)
	case *AS:
		return addASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, add(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x+y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, add)
		}
		return mapAVV(xv, y, add)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, add)
			if r.IsPanic() {
				return ppanic("d+d", r)
			}
			return r
		}
		return newDictValues(xv.keys, add(NewV(xv.values), y))
	default:
		return panicType("x+y", "x", x)
	}
}

func addFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x + float64(y.I()))
	}
	if y.IsF() {
		return NewF(x + y.F())
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x + float64(yi))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x + yi)
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x + float64(yi))
		}
		return NewV(r)
	case *D:
		v := addFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return addFV(x, yi) })
	default:
		return panicType("x+y", "y", y)
	}
}

func addIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x + y.I())
	}
	if y.IsF() {
		return NewF(float64(x) + y.F())
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AI{elts: make([]int64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(x + int64(yi))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(float64(x) + yi)
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(x + yi)
		}
		return NewV(r)
	case *D:
		v := addIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return addIV(x, yi) })
	default:
		return panicType("x+y", "y", y)
	}
}

func addSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(S(x) + S(yv)))
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(S(x) + S(yi))
		}
		return NewV(r)
	case *D:
		v := addSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return addSV(x, yi) })
	default:
		return panicType("x+y", "y", y)
	}
}

func addABV(x *AB, y V) V {
	if y.IsI() {
		r := &AI{elts: make([]int64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) + int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) + float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := &AI{elts: make([]int64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) + int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) + yv.At(i))
		}
		return NewV(r)
	case *D:
		v := addABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := addIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x+y", "y", y)
	}
}

func addAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi + float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi + float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi + float64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi + float64(yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := addAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := addFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x+y", "y", y)
	}
}

func addAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi + int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) + float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi + int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) + yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi + yv.At(i))
		}
		return NewV(r)
	case *D:
		v := addAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := addIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x+y", "y", y)
	}
}

func addASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := x.reuse()
		for i := range r.elts {
			r.elts[i] = string(S(x.At(i)) + S(yv))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(S(xi) + S(yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := addASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x+y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := addSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x+y", "y", y)
	}
}

// subtract returns x-y.
func subtract(x, y V) V {
	if x.IsI() {
		return subtractIV(x.I(), y)
	}
	if x.IsF() {
		return subtractFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return subtractSV(xv, y)
	case *AB:
		return subtractABV(xv, y)
	case *AF:
		return subtractAFV(xv, y)
	case *AI:
		return subtractAIV(xv, y)
	case *AS:
		return subtractASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, subtract(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x-y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, subtract)
		}
		return mapAVV(xv, y, subtract)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, subtract)
			if r.IsPanic() {
				return ppanic("d-d", r)
			}
			return r
		}
		return newDictValues(xv.keys, subtract(NewV(xv.values), y))
	default:
		return panicType("x-y", "x", x)
	}
}

func subtractFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x - float64(y.I()))
	}
	if y.IsF() {
		return NewF(x - y.F())
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x - float64(yi))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(x - yi)
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x - float64(yi))
		}
		return NewV(r)
	case *D:
		v := subtractFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return subtractFV(x, yi) })
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x - y.I())
	}
	if y.IsF() {
		return NewF(float64(x) - y.F())
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AI{elts: make([]int64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = int64(x - int64(yi))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(float64(x) - yi)
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = int64(x - yi)
		}
		return NewV(r)
	case *D:
		v := subtractIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return subtractIV(x, yi) })
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(strings.TrimSuffix(string(S(x)), string(S(yv)))))
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(strings.TrimSuffix(string(S(x)), string(S(yi))))
		}
		return NewV(r)
	case *D:
		v := subtractSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return subtractSV(x, yi) })
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractABV(x *AB, y V) V {
	if y.IsI() {
		r := &AI{elts: make([]int64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) - int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) - float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := &AI{elts: make([]int64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) - int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) - yv.At(i))
		}
		return NewV(r)
	case *D:
		v := subtractABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := subtractIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi - float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi - float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi - float64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi - float64(yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := subtractAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := subtractFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi - int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) - float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi - int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) - yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi - yv.At(i))
		}
		return NewV(r)
	case *D:
		v := subtractAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := subtractIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x-y", "y", y)
	}
}

func subtractASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := x.reuse()
		for i := range r.elts {
			r.elts[i] = string(strings.TrimSuffix(string(S(x.At(i))), string(S(yv))))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(strings.TrimSuffix(string(S(xi)), string(S(yv.At(i)))))
		}
		return NewV(r)
	case *D:
		v := subtractASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x-y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := subtractSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x-y", "y", y)
	}
}

// multiply returns x*y.
func multiply(x, y V) V {
	if x.IsI() {
		return multiplyIV(x.I(), y)
	}
	if x.IsF() {
		return multiplyFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return multiplySV(xv, y)
	case *AB:
		return multiplyABV(xv, y)
	case *AF:
		return multiplyAFV(xv, y)
	case *AI:
		return multiplyAIV(xv, y)
	case *AS:
		return multiplyASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, multiply(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x*y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, multiply)
		}
		return mapAVV(xv, y, multiply)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, multiply)
			if r.IsPanic() {
				return ppanic("d*d", r)
			}
			return r
		}
		return newDictValues(xv.keys, multiply(NewV(xv.values), y))
	default:
		return panicType("x*y", "x", x)
	}
}

func multiplyFV(x float64, y V) V {
	if y.IsI() {
		return NewF(x * float64(y.I()))
	}
	if y.IsF() {
		return NewF(x * y.F())
	}
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(srepeat(S(yv), int64(x))))
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x * float64(yi))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(x * yi)
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(x * float64(yi))
		}
		return NewV(r)
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(srepeat(S(yi), int64(x)))
		}
		return NewV(r)
	case *D:
		v := multiplyFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return multiplyFV(x, yi) })
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplyIV(x int64, y V) V {
	if y.IsI() {
		return NewI(x * y.I())
	}
	if y.IsF() {
		return NewF(float64(x) * y.F())
	}
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(srepeat(S(yv), x)))
	case *AB:
		r := &AI{elts: make([]int64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = int64(x * int64(yi))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(float64(x) * yi)
		}
		return NewV(r)
	case *AI:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = int64(x * yi)
		}
		return NewV(r)
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(srepeat(S(yi), x))
		}
		return NewV(r)
	case *D:
		v := multiplyIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return multiplyIV(x, yi) })
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplySV(x S, y V) V {
	if y.IsI() {
		return NewV(S(srepeat(x, y.I())))
	}
	if y.IsF() {
		return NewV(S(srepeat(x, int64(y.F()))))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AS{elts: make([]string, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = string(srepeat(S(x), int64(yi)))
		}
		return NewV(r)
	case *AF:
		r := &AS{elts: make([]string, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = string(srepeat(S(x), int64(yi)))
		}
		return NewV(r)
	case *AI:
		r := &AS{elts: make([]string, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = string(srepeat(S(x), yi))
		}
		return NewV(r)
	case *D:
		v := multiplySV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return multiplySV(x, yi) })
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplyABV(x *AB, y V) V {
	if y.IsI() {
		r := &AI{elts: make([]int64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) * int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) * float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case S:
		r := &AS{elts: make([]string, x.Len())}
		for i := range r.elts {
			r.elts[i] = string(srepeat(S(yv), int64(x.At(i))))
		}
		return NewV(r)
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := &AI{elts: make([]int64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) * int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(int64(xi) * yv.At(i))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(yv.At(i)), int64(xi)))
		}
		return NewV(r)
	case *D:
		v := multiplyABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := multiplyIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplyAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi * float64(int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi * float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case S:
		r := &AS{elts: make([]string, x.Len())}
		for i := range r.elts {
			r.elts[i] = string(srepeat(S(yv), int64(x.At(i))))
		}
		return NewV(r)
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi * float64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(xi * float64(yv.At(i)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(yv.At(i)), int64(xi)))
		}
		return NewV(r)
	case *D:
		v := multiplyAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := multiplyFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplyAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi * int64(y.I()))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) * float64(y.F()))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case S:
		r := &AS{elts: make([]string, x.Len())}
		for i := range r.elts {
			r.elts[i] = string(srepeat(S(yv), x.At(i)))
		}
		return NewV(r)
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi * int64(yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(float64(xi) * yv.At(i))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(xi * yv.At(i))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(yv.At(i)), xi))
		}
		return NewV(r)
	case *D:
		v := multiplyAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := multiplyIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x*y", "y", y)
	}
}

func multiplyASV(x *AS, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(xi), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(xi), int64(float64(y.F()))))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(xi), int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(xi), int64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(srepeat(S(xi), yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := multiplyASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x*y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := multiplySV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x*y", "y", y)
	}
}

// divide returns x%y.
func divide(x, y V) V {
	if x.IsI() {
		return divideIV(x.I(), y)
	}
	if x.IsF() {
		return divideFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case *AB:
		return divideABV(xv, y)
	case *AF:
		return divideAFV(xv, y)
	case *AI:
		return divideAIV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, divide(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x%y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, divide)
		}
		return mapAVV(xv, y, divide)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, divide)
			if r.IsPanic() {
				return ppanic("d%d", r)
			}
			return r
		}
		return newDictValues(xv.keys, divide(NewV(xv.values), y))
	default:
		return panicType("x%y", "x", x)
	}
}

func divideFV(x float64, y V) V {
	if y.IsI() {
		return NewF(divideF(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(divideF(x, y.F()))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(x, float64(yi)))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(x, yi))
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(x, float64(yi)))
		}
		return NewV(r)
	case *D:
		v := divideFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return divideFV(x, yi) })
	default:
		return panicType("x%y", "y", y)
	}
}

func divideIV(x int64, y V) V {
	if y.IsI() {
		return NewF(divideF(float64(x), float64(y.I())))
	}
	if y.IsF() {
		return NewF(divideF(float64(x), y.F()))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(float64(x), float64(yi)))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(float64(x), yi))
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(divideF(float64(x), float64(yi)))
		}
		return NewV(r)
	case *D:
		v := divideIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return divideIV(x, yi) })
	default:
		return panicType("x%y", "y", y)
	}
}

func divideABV(x *AB, y V) V {
	if y.IsI() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := divideABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := divideIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x%y", "y", y)
	}
}

func divideAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(xi, float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(xi, float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(xi, yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := divideAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := divideFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x%y", "y", y)
	}
}

func divideAIV(x *AI, y V) V {
	if y.IsI() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(divideF(float64(xi), float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := divideAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x%y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := divideIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x%y", "y", y)
	}
}

// minimum returns x&y.
func minimum(x, y V) V {
	if x.IsI() {
		return minimumIV(x.I(), y)
	}
	if x.IsF() {
		return minimumFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return minimumSV(xv, y)
	case *AB:
		return minimumABV(xv, y)
	case *AF:
		return minimumAFV(xv, y)
	case *AI:
		return minimumAIV(xv, y)
	case *AS:
		return minimumASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, minimum(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x&y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, minimum)
		}
		return mapAVV(xv, y, minimum)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, minimum)
			if r.IsPanic() {
				return ppanic("d&d", r)
			}
			return r
		}
		return newDictValues(xv.keys, minimum(NewV(xv.values), y))
	default:
		return panicType("x&y", "x", x)
	}
}

func minimumFV(x float64, y V) V {
	if y.IsI() {
		return NewF(math.Min(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(math.Min(x, float64(y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Min(x, float64(yi)))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Min(x, float64(yi)))
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Min(x, float64(yi)))
		}
		return NewV(r)
	case *D:
		v := minimumFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return minimumFV(x, yi) })
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumIV(x int64, y V) V {
	if y.IsI() {
		return NewI(minI(x, y.I()))
	}
	if y.IsF() {
		return NewF(math.Min(float64(x), y.F()))
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AI{elts: make([]int64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(minI(x, int64(yi)))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Min(float64(x), yi))
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(minI(x, yi))
		}
		return NewV(r)
	case *D:
		v := minimumIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return minimumIV(x, yi) })
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(minS(S(x), S(yv))))
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(minS(S(x), S(yi)))
		}
		return NewV(r)
	case *D:
		v := minimumSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return minimumSV(x, yi) })
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumABV(x *AB, y V) V {
	if y.IsI() {
		r := &AI{elts: make([]int64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(minI(int64(xi), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		b := x.IsBoolean() && yv.IsBoolean()
		r := x.reuse()
		if b {
			for i, xi := range x.elts {
				r.elts[i] = xi & yv.At(i)
			}
			r.flags |= flagBool
			return NewV(r)
		}
		for i, xi := range x.elts {
			r.elts[i] = byte(minB(xi, yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(minI(int64(xi), yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := minimumABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := minimumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(xi, float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(xi, float64(float64(y.F()))))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := minimumAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := minimumFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(minI(xi, int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(minI(xi, int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Min(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(minI(xi, yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := minimumAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := minimumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x&y", "y", y)
	}
}

func minimumASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := x.reuse()
		for i := range r.elts {
			r.elts[i] = string(minS(S(x.At(i)), S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(minS(S(xi), S(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := minimumASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x&y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := minimumSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x&y", "y", y)
	}
}

// maximum returns x|y.
func maximum(x, y V) V {
	if x.IsI() {
		return maximumIV(x.I(), y)
	}
	if x.IsF() {
		return maximumFV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case S:
		return maximumSV(xv, y)
	case *AB:
		return maximumABV(xv, y)
	case *AF:
		return maximumAFV(xv, y)
	case *AI:
		return maximumAIV(xv, y)
	case *AS:
		return maximumASV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, maximum(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x|y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, maximum)
		}
		return mapAVV(xv, y, maximum)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, maximum)
			if r.IsPanic() {
				return ppanic("d|d", r)
			}
			return r
		}
		return newDictValues(xv.keys, maximum(NewV(xv.values), y))
	default:
		return panicType("x|y", "x", x)
	}
}

func maximumFV(x float64, y V) V {
	if y.IsI() {
		return NewF(math.Max(x, float64(y.I())))
	}
	if y.IsF() {
		return NewF(math.Max(x, float64(y.F())))
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Max(x, float64(yi)))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Max(x, float64(yi)))
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := &AF{elts: make([]float64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Max(x, float64(yi)))
		}
		return NewV(r)
	case *D:
		v := maximumFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return maximumFV(x, yi) })
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumIV(x int64, y V) V {
	if y.IsI() {
		return NewI(maxI(x, y.I()))
	}
	if y.IsF() {
		return NewF(math.Max(float64(x), y.F()))
	}
	switch yv := y.bv.(type) {
	case *AB:
		asc := ascending(yv)
		r := &AI{elts: make([]int64, yv.Len())}
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(maxI(x, int64(yi)))
		}
		return NewV(r)
	case *AF:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Max(float64(x), yi))
		}
		return NewV(r)
	case *AI:
		asc := ascending(yv)
		r := yv.reuse()
		if asc {
			r.flags |= flagAscending
		}
		for i, yi := range yv.elts {
			r.elts[i] = int64(maxI(x, yi))
		}
		return NewV(r)
	case *D:
		v := maximumIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return maximumIV(x, yi) })
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumSV(x S, y V) V {
	switch yv := y.bv.(type) {
	case S:
		return NewV(S(maxS(S(x), S(yv))))
	case *AS:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = string(maxS(S(x), S(yi)))
		}
		return NewV(r)
	case *D:
		v := maximumSV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return maximumSV(x, yi) })
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumABV(x *AB, y V) V {
	if y.IsI() {
		r := &AI{elts: make([]int64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = int64(maxI(int64(xi), int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		b := x.IsBoolean() && yv.IsBoolean()
		r := x.reuse()
		if b {
			for i, xi := range x.elts {
				r.elts[i] = xi | yv.At(i)
			}
			r.flags |= flagBool
			return NewV(r)
		}
		for i, xi := range x.elts {
			r.elts[i] = byte(maxB(xi, yv.At(i)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(maxI(int64(xi), yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := maximumABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := maximumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumAFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(xi, float64(int64(y.I()))))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(xi, float64(float64(y.F()))))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(xi, float64(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := maximumAFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := maximumFV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumAIV(x *AI, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(maxI(xi, int64(y.I())))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(float64(xi), float64(y.F())))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(maxI(xi, int64(yv.At(i))))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Max(float64(xi), yv.At(i)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = int64(maxI(xi, yv.At(i)))
		}
		return NewV(r)
	case *D:
		v := maximumAIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := maximumIV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x|y", "y", y)
	}
}

func maximumASV(x *AS, y V) V {
	switch yv := y.bv.(type) {
	case S:
		r := x.reuse()
		for i := range r.elts {
			r.elts[i] = string(maxS(S(x.At(i)), S(yv)))
		}
		return NewV(r)
	case *AS:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = string(maxS(S(xi), S(yv.At(i))))
		}
		return NewV(r)
	case *D:
		v := maximumASV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x|y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := maximumSV(S(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x|y", "y", y)
	}
}

// arctan2 returns x atan y.
func arctan2(x, y V) V {
	if x.IsI() {
		return arctan2IV(x.I(), y)
	}
	if x.IsF() {
		return arctan2FV(x.F(), y)
	}
	switch xv := x.bv.(type) {
	case *AB:
		return arctan2ABV(xv, y)
	case *AF:
		return arctan2AFV(xv, y)
	case *AI:
		return arctan2AIV(xv, y)
	case *AV:
		switch yv := y.bv.(type) {
		case *D:
			return newDictValues(yv.keys, arctan2(x, NewV(yv.values)))
		case Array:
			if yv.Len() != xv.Len() {
				return panicLength("x atan y", xv.Len(), yv.Len())
			}
			return mapAVArray(xv, yv, arctan2)
		}
		return mapAVV(xv, y, arctan2)
	case *D:
		yv, ok := y.bv.(*D)
		if ok {
			r := dictArith(xv, yv, arctan2)
			if r.IsPanic() {
				return ppanic("d atan d", r)
			}
			return r
		}
		return newDictValues(xv.keys, arctan2(NewV(xv.values), y))
	default:
		return panicType("x atan y", "x", x)
	}
}

func arctan2FV(x float64, y V) V {
	if y.IsI() {
		return NewF(math.Atan2(float64(y.I()), x))
	}
	if y.IsF() {
		return NewF(math.Atan2(y.F(), x))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(float64(yi), x))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(yi, x))
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(float64(yi), x))
		}
		return NewV(r)
	case *D:
		v := arctan2FV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return arctan2FV(x, yi) })
	default:
		return panicType("x atan y", "y", y)
	}
}

func arctan2IV(x int64, y V) V {
	if y.IsI() {
		return NewF(math.Atan2(float64(y.I()), float64(x)))
	}
	if y.IsF() {
		return NewF(math.Atan2(y.F(), float64(x)))
	}
	switch yv := y.bv.(type) {
	case *AB:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(float64(yi), float64(x)))
		}
		return NewV(r)
	case *AF:
		r := yv.reuse()
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(yi, float64(x)))
		}
		return NewV(r)
	case *AI:
		r := &AF{elts: make([]float64, yv.Len())}
		for i, yi := range yv.elts {
			r.elts[i] = float64(math.Atan2(float64(yi), float64(x)))
		}
		return NewV(r)
	case *D:
		v := arctan2IV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		return mapAV(yv, func(yi V) V { return arctan2IV(x, yi) })
	default:
		return panicType("x atan y", "y", y)
	}
}

func arctan2ABV(x *AB, y V) V {
	if y.IsI() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(int64(y.I())), float64(xi)))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(y.F()), float64(xi)))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), float64(xi)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(yv.At(i), float64(xi)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), float64(xi)))
		}
		return NewV(r)
	case *D:
		v := arctan2ABV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := arctan2IV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x atan y", "y", y)
	}
}

func arctan2AFV(x *AF, y V) V {
	if y.IsI() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(int64(y.I())), xi))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(y.F()), xi))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), xi))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(yv.At(i), xi))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := x.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), xi))
		}
		return NewV(r)
	case *D:
		v := arctan2AFV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := arctan2FV(float64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x atan y", "y", y)
	}
}

func arctan2AIV(x *AI, y V) V {
	if y.IsI() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(int64(y.I())), float64(xi)))
		}
		return NewV(r)
	}
	if y.IsF() {
		r := &AF{elts: make([]float64, x.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(y.F()), float64(xi)))
		}
		return NewV(r)
	}
	switch yv := y.bv.(type) {
	case *AB:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), float64(xi)))
		}
		return NewV(r)
	case *AF:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(yv.At(i), float64(xi)))
		}
		return NewV(r)
	case *AI:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := &AF{elts: make([]float64, yv.Len())}
		for i, xi := range x.elts {
			r.elts[i] = float64(math.Atan2(float64(yv.At(i)), float64(xi)))
		}
		return NewV(r)
	case *D:
		v := arctan2AIV(x, NewV(yv.values))
		if v.IsPanic() {
			return v
		}
		return NewV(&D{keys: yv.keys, values: v.bv.(Array)})
	case *AV:
		if x.Len() != yv.Len() {
			return panicLength("x atan y", x.Len(), yv.Len())
		}
		r := yv.reuse()
		for i := range r.elts {
			ri := arctan2IV(int64(x.At(i)), yv.At(i))
			if ri.IsPanic() {
				return ri
			}
			ri.MarkImmutable()
			r.elts[i] = ri
		}
		return NewV(r)
	default:
		return panicType("x atan y", "y", y)
	}
}

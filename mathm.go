// Code generated by scripts/math.goal. DO NOT EDIT.

package goal

import "math"

func mathm(x V, f func(float64) float64) V {
	if x.IsI() {
		return NewF(f(float64(x.I())))
	}
	if x.IsF() {
		return NewF(f(x.F()))
	}
	switch xv := x.bv.(type) {
	case *AB:
		r := make([]float64, xv.Len())
		for i, xi := range xv.elts {
			r[i] = f(float64(xi))
		}
		return NewAF(r)
	case *AI:
		r := make([]float64, xv.Len())
		for i, xi := range xv.elts {
			r[i] = f(float64(xi))
		}
		return NewAF(r)
	case *AF:
		r := xv.reuse()
		for i, xi := range xv.elts {
			r.elts[i] = f(xi)
		}
		return NewV(r)
	case *AV:
		return monadAV(xv, func(xi V) V { return mathm(xi, f) })
	case *Dict:
		r := mathm(NewV(xv.values), f)
		return NewV(&Dict{keys: xv.keys, values: r.bv.(array)})
	default:
		return Panicf("bad type \"%s\" in x", x.Type())
	}
}

// vfCos implements the cos variadic.
func vfCos(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.Cos)
		if r.IsPanic() {
			return ppanic("cos x : ", r)
		}
		return r
	default:
		return panicRank("cos")
	}
}

// vfExp implements the exp variadic.
func vfExp(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.Exp)
		if r.IsPanic() {
			return ppanic("exp x : ", r)
		}
		return r
	default:
		return panicRank("exp")
	}
}

// vfLog implements the log variadic.
func vfLog(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.Log)
		if r.IsPanic() {
			return ppanic("log x : ", r)
		}
		return r
	default:
		return panicRank("log")
	}
}

// vfRoundToEven implements the round variadic.
func vfRoundToEven(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.RoundToEven)
		if r.IsPanic() {
			return ppanic("round x : ", r)
		}
		return r
	default:
		return panicRank("round")
	}
}

// vfSin implements the sin variadic.
func vfSin(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.Sin)
		if r.IsPanic() {
			return ppanic("sin x : ", r)
		}
		return r
	default:
		return panicRank("sin")
	}
}

// vfSqrt implements the sqrt variadic.
func vfSqrt(ctx *Context, args []V) V {
	switch len(args) {
	case 1:
		r := mathm(args[0], math.Sqrt)
		if r.IsPanic() {
			return ppanic("sqrt x : ", r)
		}
		return r
	default:
		return panicRank("sqrt")
	}
}

package:`
// Code generated by scripts/math.goal. DO NOT EDIT.

package goal

import "math"
`
mathm:`
func mathm(x V, f func(float64) float64) V {
        if x.IsI() {
                return NewF(f(float64(x.I())))
        }
        if x.IsF() {
                return NewF(f(x.F()))
        }
        switch xv := x.value.(type) {
        case *AB:
                r := make([]float64, xv.Len())
                for i, xi := range xv.Slice {
                        r[i] = f(b2f(xi))
                }
                return NewAFWithRC(r, reuseRCp(xv.rc))
        case *AI:
                r := make([]float64, xv.Len())
                for i, xi := range xv.Slice {
                        r[i] = f(float64(xi))
                }
                return NewAFWithRC(r, reuseRCp(xv.rc))
        case *AF:
                r := xv.reuse()
                for i, xi := range xv.Slice {
                        r.Slice[i] = f(xi)
                }
                return NewV(r)
        case *AV:
                r := xv.reuse()
                for i, xi := range xv.Slice {
                        ri := mathm(xi, f)
                        if ri.IsPanic() {
                                return ri
                        }
                        r.Slice[i] = ri
                }
                return NewV(r)
        case *Dict:
                r := mathm(NewV(xv.values), f)
                r.InitRC()
                return NewV(&Dict{keys: xv.keys, values: r.value.(array)})
        default:
                return Panicf("bad type in x (%s)", x.Type())
        }
}
`
ftpl:{[N;n]qq#
// V$N implements the $n variadic.
func V$N(ctx *Context, args []V) V {
        switch len(args) {
        case 1:
                r := mathm(args[0], math.$N)
                if r.IsPanic() {
                        return ppanic("$n x : ", r)
                }
                return r
        default:
                return panicRank("$n")
        }
}
#}
funcs:+/({ftpl . x}'(
  "Acos" "acos"
  "Asin" "asin"
  "Atan" "atan"
  "Cos" "cos"
  "Exp" "exp"
  "Log" "log"
  "RoundToEven" "round"
  "Sin" "sin"
  "Sqrt" "sqrt"
  "Tan" "tan"
))
'"../mathm.go" say package+mathm+funcs
'run "gofmt" "-s" "-w" "../mathm.go"

package:`
// Code generated by scripts/math.goal. DO NOT EDIT.

package goal

import "math"
`
mathm:`
func mathm(x V, f func(float64) float64) V {
        if x.IsI() {
                return NewF(f(float64(x.I())))
        }
        if x.IsF() {
                return NewF(f(x.F()))
        }
        switch xv := x.bv.(type) {
        case *AB:
                r := make([]float64, xv.Len())
                for i, xi := range xv.elts {
                        r[i] = f(float64(xi))
                }
                return NewAF(r)
        case *AI:
                r := make([]float64, xv.Len())
                for i, xi := range xv.elts {
                        r[i] = f(float64(xi))
                }
                return NewAF(r)
        case *AF:
                r := xv.reuse()
                for i, xi := range xv.elts {
                        r.elts[i] = f(xi)
                }
                return NewV(r)
        case *AV:
                return monadAV(xv, func(xi V) V { return mathm(xi, f) })
        case *Dict:
                r := mathm(NewV(xv.values), f)
                return NewV(&Dict{keys: xv.keys, values: r.bv.(array)})
        default:
                return Panicf("bad type \"%s\" in x", x.Type())
        }
}
`
ftpl:{[N;n]qq#
// vf$N implements the $n variadic.
func vf$N(ctx *Context, args []V) V {
        switch len(args) {
        case 1:
                r := mathm(args[0], math.$N)
                if r.IsPanic() {
                        return ppanic("$n x : ", r)
                }
                return r
        default:
                return panicRank("$n")
        }
}
#}
funcs:+/({ftpl . x}'(
  "Cos" "cos"
  "Exp" "exp"
  "Log" "log"
  "RoundToEven" "round"
  "Sin" "sin"
  "Sqrt" "sqrt"
))
'"../mathm.go" say package+mathm+funcs
'run "gofmt" "-s" "-w" "../mathm.go"

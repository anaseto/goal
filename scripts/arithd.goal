package:"\n"_`
// Code generated by scripts/arithd.goal. DO NOT EDIT.

package goal

import (
    "math"
    "strings"
)
`

keys:"xt" "yt" "expr" "rt"
equal:keys!+(
  "B" "B" "x == y" "B"
  "B" "I" "b2i(x) == y" "B"
  "B" "F" "b2f(x) == y" "B"
  "I" "B" "x == b2i(y)" "B"
  "I" "I" "x == y" "B"
  "I" "F" "float64(x) == y" "B"
  "F" "B" "x == b2f(y)" "B"
  "F" "I" "x == float64(y)" "B"
  "F" "F" "x == y" "B"
  "S" "S" "x == y" "B"
)
lesser:keys!+(
  "B" "B" "!x && y" "B"
  "B" "I" "b2i(x) < y" "B"
  "B" "F" "b2f(x) < y" "B"
  "I" "B" "x < b2i(y)" "B"
  "I" "I" "x < y" "B"
  "I" "F" "float64(x) < y" "B"
  "F" "B" "x < b2f(y)" "B"
  "F" "I" "x < float64(y)" "B"
  "F" "F" "x < y" "B"
  "S" "S" "x < y" "B"
)
greater:keys!+(
  "B" "B" "x && !y" "B"
  "B" "I" "b2i(x) > y" "B"
  "B" "F" "b2f(x) > y" "B"
  "I" "B" "x > b2i(y)" "B"
  "I" "I" "x > y" "B"
  "I" "F" "float64(x) > y" "B"
  "F" "B" "x > b2f(y)" "B"
  "F" "I" "x > float64(y)" "B"
  "F" "F" "x > y" "B"
  "S" "S" "x > y" "B"
)
add:keys!+(
  "B" "B" "b2i(x) + b2i(y)" "I"
  "B" "I" "b2i(x) + y" "I"
  "B" "F" "b2f(x) + y" "F"
  "I" "B" "x + b2i(y)" "I"
  "I" "I" "x + y" "I"
  "I" "F" "float64(x) + y" "F"
  "F" "B" "x + b2f(y)" "F"
  "F" "I" "x + float64(y)" "F"
  "F" "F" "x + y" "F"
  "S" "S" "x + y" "S"
)
subtract:keys!+(
  "B" "B" "b2i(x) - b2i(y)" "I"
  "B" "I" "b2i(x) - y" "I"
  "B" "F" "b2f(x) - y" "F"
  "I" "B" "x - b2i(y)" "I"
  "I" "I" "x - y" "I"
  "I" "F" "float64(x) - y" "F"
  "F" "B" "x - b2f(y)" "F"
  "F" "I" "x - float64(y)" "F"
  "F" "F" "x - y" "F"
  "S" "S" "strings.TrimSuffix(string(x), string(y))" "S"
)
multiply:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "b2i(x) * y" "I"
  "B" "F" "b2f(x) * y" "F"
  "B" "S" "srepeat(y, b2i(x))" "S"
  "I" "B" "x * b2i(y)" "I"
  "I" "I" "x * y" "I"
  "I" "F" "float64(x) * y" "F"
  "I" "S" "srepeat(y, x)" "S"
  "F" "B" "x * b2f(y)" "F"
  "F" "I" "x * float64(y)" "F"
  "F" "F" "x * y" "F"
  "F" "S" "srepeat(y, int64(x))" "S"
  "S" "B" "srepeat(x, b2i(y))" "S"
  "S" "I" "srepeat(x, y)" "S"
  "S" "F" "srepeat(x, int64(y))" "S"
)
divide:keys!+(
  "B" "B" "divideF(b2f(x), b2f(y))" "F"
  "B" "I" "divideF(b2f(x), float64(y))" "F"
  "B" "F" "divideF(b2f(x), y)" "F"
  "I" "B" "divideF(float64(x), b2f(y))" "F"
  "I" "I" "divideF(float64(x), float64(y))" "F"
  "I" "F" "divideF(float64(x), y)" "F"
  "F" "B" "divideF(x, b2f(y))" "F"
  "F" "I" "divideF(x, float64(y))" "F"
  "F" "F" "divideF(x, y)" "F"
)
minimum:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "minI(b2i(x), y)" "I"
  "B" "F" "math.Min(b2f(x), y)" "F"
  "I" "B" "minI(x, b2i(y))" "I"
  "I" "I" "minI(x, y)" "I"
  "I" "F" "math.Min(float64(x), y)" "F"
  "F" "B" "math.Min(x, b2f(y))" "F"
  "F" "I" "math.Min(x, float64(y))" "F"
  "F" "F" "math.Min(x, float64(y))" "F"
  "S" "S" "minS(x, y)" "S"
)
maximum:keys!+(
  "B" "B" "x || y" "B"
  "B" "I" "maxI(b2i(x), y)" "I"
  "B" "F" "math.Max(b2f(x), y)" "F"
  "I" "B" "maxI(x, b2i(y))" "I"
  "I" "I" "maxI(x, y)" "I"
  "I" "F" "math.Max(float64(x), y)" "F"
  "F" "B" "math.Max(x, b2f(y))" "F"
  "F" "I" "math.Max(x, float64(y))" "F"
  "F" "F" "math.Max(x, float64(y))" "F"
  "S" "S" "maxS(x, y)" "S"
)
modulus:keys!+(
  "B" "B" "modI(b2i(x), b2i(y))" "I"
  "B" "I" "modI(b2i(x), y)" "I"
  "B" "F" "modF(b2f(x), y)" "F"
  "I" "B" "modI(x, b2i(y))" "I"
  "I" "I" "modI(x, y)" "I"
  "I" "F" "modF(float64(x), y)" "F"
  "F" "B" "modF(x, b2f(y))" "F"
  "F" "I" "modF(x, float64(y))" "F"
  "F" "F" "modF(x, y)" "F"
)

ops:(
  "equal" "="
  "lesser" "<"
  "greater" ">"
  "add" "+"
  "subtract" "-"
  "multiply" "*"
  "divide" "%"
  "minimum" "&"
  "maximum" "|"
  "modulus" " mod "
)

types:"B" "F" "I" "S" / atom types
ntypes:"B" "F" "I" / numeric atom types
itypes:"B" "I" / integer atom types
gotypes:"bool" "float64" "int64" "string" / concrete types
gontypes:"bool" "float64" "int64" "S" / concrete numeric types
utypes:"F" "I" / atom unboxed types
t2go:types!gotypes / type to concrete go type
nt2go:types!gontypes / type to concrete go type
olts:{?x["xt"]} / operator x left types
orts:{?x["yt"][&x["xt"]=y]} / operator x right types for left type y
getET:{x["expr" "rt"][;*&(x["xt"]=y)&x["yt"]=z]} / expression and ret type for type couple
escp:sub["%";"%%"] / percent escape
doExpr:{[e;yt;x;y]
  e:?[~xt in ntypes;sub[rx/(!x|\bx)\b/;xt+"($1)"]e;e]
  e:?[~yt in ntypes;sub[rx/(!x|\by)\b/;yt+"($1)"]e;e]
  sub[rx/\by\b/;y]sub[rx/\bx\b/;x]e
}
rmbl:sub[rx/\n\s*\n/;"\n"]

genOp:{[opname;opsym] / globals o,op,xt
  o::opname; op::opsym; ts:olts[::o]
  say sub[("{O}";o;"{OP}";op)] "\n"_`
    // {O} returns x{OP}y.
    func {O}(x, y V) V {`
  say'{sub[("{XT}";x;"{O}";o)][
      `if x.Is{XT}() { return {O}{XT}V(x.{XT}(), y) }`
  ]}'utypes#ts
  say `switch xv := x.value.(type) {`
  say'{sub[("{XT}";x;"{O}";o)] `  case {XT}: return {O}{XT}V(xv, y)`}'^(ntypes^ts)
  say'{sub[("{XT}";x;"{O}";o)] `  case *{XT}: return {O}{XT}V(xv, y)`}'^"A"+ts
  say sub[("{OP}";escp op;"{O}";o)]"\n"_`
    case *AV:
        switch yv := y.value.(type) {
        case *Dict:
              v := {O}(x, NewV(yv.values))
              if v.IsPanic() {
                      return v
              }
              v.InitRC()
              return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
        case array:
              if yv.Len() != xv.Len() {
                      return Panicf("x{OP}y : length mismatch: %d vs %d", xv.Len(), yv.Len())
              }`
  tplAV:"\n"_`
    r := xv.reuse()
    for i, xi := range xv.Slice {
            ri := {O}(xi, {YY})
            if ri.IsPanic() {
                    return ri
            }
            r.Slice[i] = ri
    }
    return NewV(r)`
  say sub[("{O}";o;"{YY}";"yv.at(i)")] tplAV
  say `}`
  say sub[("{O}";o;"{YY}";"y")] tplAV
  say sub[("{O}";o;"{OP}";op)]"\n"_`
    case *Dict:
        yv, ok := y.value.(*Dict)
        if ok {
            r := dictArith(xv, yv, {O})
            if r.IsPanic() {
                    return ppanic("d{OP}d", r)
            }
            return r
        }
        v := {O}(NewV(xv.values), y)
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: xv.keys, values: v.value.(array)})`
  say sub["{OP}";op]"\n"_`
    default:
          return panicTypeElt("x{OP}y", "x", x)
    }
  }
  `
  dox'^(,"B")^ts / cases with atom x
  doX'^ts        / cases with array x
}

dox:{
  xt::x; rts:orts[::o;xt]; xct:nt2go xt
  xUy:"\n"/{(e;t):getET[::o;xt;x];doxUy[x;e;t]}'utypes#rts
  xBy:"\n"/{(e;t):getET[::o;xt;x];doxBy[x;e;t]}'^ntypes^rts
  xY:"\n"/{(e;t):getET[::o;xt;x];doxY[x;e;t]}'^rts
  xdAV:doxdAV""
  repls:("{O}";o;"{XT}";xt;"{XCT}";xct;"{xUy}";xUy;"{xBy}";xBy;"{xY}";xY;"{xdAV}";xdAV)
  say rmbl sub[repls] "\n"_`
    func {O}{XT}V(x {XCT}, y V) V {
        {xUy}
        switch yv := y.value.(type) {
        {xBy}
        {xY}
        {xdAV}
        }
    }
    `
}
doxUy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  e:sub[rx/\by\b/;"y."+yt+"()"]e
  t:?[t~"B";"I";t]
  e:?[t in utypes;+/("New";t;"(";e;")");+/("NewV";"(";t;"(";e;"))")]
  sub[("{YT}";yt;"{E}";e)] `if y.Is{YT}() { return {E}; }`
}
doxBy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  nt:?[t in itypes;"I";t~"F";"F";"V"]
  e:doExpr[e;yt;"x";"yv"]
  t:nt2go t
  t:?[t~"bool";"int64";t]
  sub[("{YT}";yt;"{NT}";nt;"{RT}";t;"{E}";e)]`  case {YT}: return New{NT}({RT}({E}))`
}
doxY:{[yt;e;t]
  e:doExpr[e;yt;"x";"yv.At(i)"]
  rt:t2go t
  ?[yt~t
   sub[("{YT}";yt;"{RT}";rt;"{E}";e)]"\n"_`
    case *A{YT}:
        r := yv.reuse()
        for i := range r.Slice {
                r.Slice[i] = {RT}({E})
        }
        return NewV(r)`
   sub[("{YT}";yt;"{RT}";rt;"{E}";e;"{T}";t)]"\n"_`
    case *A{YT}:
        r := make([]{RT}, yv.Len())
        for i := range r {
                r[i] = {RT}({E})
        }
        return NewA{T}WithRC(r, reuseRCp(yv.rc))`]
}
doxdAV:{
  sub[("{O}";o;"{XT}";xt;"{OP}";op)]"\n"_`
    case *Dict:
        v := {O}{XT}V(x, NewV(yv.values))
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
        r := yv.reuse()
        for i, yi := range yv.Slice {
                ri := {O}{XT}V(x, yi)
                if ri.IsPanic() {
                        return ri
                }
                r.Slice[i] = ri
        }
        return NewV(r)
    default:
        return panicTypeElt("x{OP}y", "y", y)`
}

doX:{
  xt::x; rts:orts[::o;xt]; xct:t2go xt
  XUy:"\n"/{(e;t):getET[::o;xt;x];doXUy[x;e;t]}'utypes#rts
  XBy:"\n"/{(e;t):getET[::o;xt;x];doXBy[x;e;t]}'^ntypes^rts
  XY:"\n"/{(e;t):getET[::o;xt;x];doXY[x;e;t]}'^rts
  XdAV:doXdAV""
  repls:("{O}";o;"{XT}";xt;"{XUy}";XUy;"{XBy}";XBy;"{XY}";XY;"{XdAV}";XdAV)
  say rmbl sub[repls] "\n"_`
    func {O}A{XT}V(x *A{XT}, y V) V {
        {XUy}
        switch yv := y.value.(type) {
        {XBy}
        {XY}
        {XdAV}
        }
    }
    `
}
doXUy:{[yt;e;t]
  e:doExpr[e;t2go yt;"x.At(i)";"y."+yt+"()"]
  rt:t2go t
  ?[xt~t
    sub[("{YT}";yt;"{RT}";rt;"{E}";e)]"\n"_`
      if y.Is{YT}() {
          r := x.reuse()
          for i := range r.Slice {
                  r.Slice[i] = {RT}({E})
          }
          return NewV(r)
      }`
   sub[("{YT}";yt;"{RT}";rt;"{E}";e;"{T}";t)]"\n"_`
      if y.Is{YT}() {
          r := make([]{RT}, x.Len())
          for i := range r {
                  r[i] = {RT}({E})
          }
          return NewA{T}WithRC(r, reuseRCp(x.rc))
      }`]
}
doXBy:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv"]
  rt:t2go t
  ?[xt~t
    sub[("{YT}";yt;"{RT}";rt;"{E}";e)]"\n"_`
      case {YT}:
              r := x.reuse()
              for i := range r.Slice {
                      r.Slice[i] = {RT}({E})
              }
              return NewV(r)`
    sub[("{YT}";yt;"{RT}";rt;"{E}";e;"{T}";t)]"\n"_`
      case {YT}:
              r := make([]{RT}, x.Len())
              for i := range r {
                      r[i] = {RT}({E})
              }
              return NewA{T}WithRC(r, reuseRCp(x.rc))`]
}
doXY:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv.At(i)"]
  rt:t2go t
  s1:sub[("{YT}";yt;"{OP}";escp op)]"\n"_`
    case *A{YT}:
            if x.Len() != yv.Len() {
                    return Panicf("x{OP}y : length mismatch: %d vs %d", x.Len(), yv.Len())
            }`
  s2:?[t in xt,yt
    sub[("{RT}";rt;"{E}";e;"{XY}";?[xt~t;"x";"yv"])]"\n"_`
          r := {XY}.reuse()
          for i := range r.Slice {
                  r.Slice[i] = {RT}({E})
          }
          return NewV(r)`
    sub[("{RT}";rt;"{E}";e;"{T}";t)]"\n"_`
          r := make([]{RT}, yv.Len())
          for i := range r {
                  r[i] = {RT}({E})
          }
          return NewA{T}WithRC(r, reuseRCp(x.rc))`]
  "\n"/(s1;s2)
}
doXdAV:{
  nxt:?[xt~"B";"I";xt]
  xct:?[xt~"B";"b2i";xt~"I";"int64";xt~"F";"float64";xt]
  sub[("{OPE}";escp op;"{OP}";op;"{O}";o;"{XT}";xt;"{NXT}";nxt;"{XCT}";xct)]"\n"_`
    case *Dict:
            v := {O}A{XT}V(x, NewV(yv.values))
            if v.IsPanic() {
                    return v
            }
            v.InitRC()
            return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
            if x.Len() != yv.Len() {
                    return Panicf("x{OPE}y : length mismatch: %d vs %d", x.Len(), yv.Len())
            }
            r := yv.reuse()
            for i := range r.Slice {
                    ri := {O}{NXT}V({XCT}(x.At(i)), yv.At(i))
                    if ri.IsPanic() {
                            return ri
                    }
                    r.Slice[i] = ri
            }
            return NewV(r)
    default:
            return panicTypeElt("x{OP}y", "y", y)`
}

say package
{genOp . x}'ops

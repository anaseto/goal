package:"\n"_`
// Code generated by scripts/arithd.goal. DO NOT EDIT.

package goal

import (
    "math"
    "strings"
)
`

keys:"xt" "yt" "expr" "rt"
equal:keys!+(
  "B" "B" "b2B(x == y)" "B"
  "B" "I" "b2B(int64(x) == y)" "B"
  "B" "F" "b2B(float64(x) == y)" "B"
  "I" "B" "b2B(x == int64(y))" "B"
  "I" "I" "b2B(x == y)" "B"
  "I" "F" "b2B(float64(x) == y)" "B"
  "F" "B" "b2B(x == float64(y))" "B"
  "F" "I" "b2B(x == float64(y))" "B"
  "F" "F" "b2B(x == y)" "B"
  "S" "S" "b2B(x == y)" "B"
)
lesser:keys!+(
  "B" "B" "b2B(x < y)" "B"
  "B" "I" "b2B(int64(x) < y)" "B"
  "B" "F" "b2B(float64(x) < y)" "B"
  "I" "B" "b2B(x < int64(y))" "B"
  "I" "I" "b2B(x < y)" "B"
  "I" "F" "b2B(float64(x) < y)" "B"
  "F" "B" "b2B(x < float64(y))" "B"
  "F" "I" "b2B(x < float64(y))" "B"
  "F" "F" "b2B(x < y)" "B"
  "S" "S" "b2B(x < y)" "B"
)
greater:keys!+(
  "B" "B" "b2B(x > y)" "B"
  "B" "I" "b2B(int64(x) > y)" "B"
  "B" "F" "b2B(float64(x) > y)" "B"
  "I" "B" "b2B(x > int64(y))" "B"
  "I" "I" "b2B(x > y)" "B"
  "I" "F" "b2B(float64(x) > y)" "B"
  "F" "B" "b2B(x > float64(y))" "B"
  "F" "I" "b2B(x > float64(y))" "B"
  "F" "F" "b2B(x > y)" "B"
  "S" "S" "b2B(x > y)" "B"
)
add:keys!+(
  "B" "B" "int64(x) + int64(y)" "I"
  "B" "I" "int64(x) + y" "I"
  "B" "F" "float64(x) + y" "F"
  "I" "B" "x + int64(y)" "I"
  "I" "I" "x + y" "I"
  "I" "F" "float64(x) + y" "F"
  "F" "B" "x + float64(y)" "F"
  "F" "I" "x + float64(y)" "F"
  "F" "F" "x + y" "F"
  "S" "S" "x + y" "S"
)
subtract:keys!+(
  "B" "B" "int64(x) - int64(y)" "I"
  "B" "I" "int64(x) - y" "I"
  "B" "F" "float64(x) - y" "F"
  "I" "B" "x - int64(y)" "I"
  "I" "I" "x - y" "I"
  "I" "F" "float64(x) - y" "F"
  "F" "B" "x - float64(y)" "F"
  "F" "I" "x - float64(y)" "F"
  "F" "F" "x - y" "F"
  "S" "S" "strings.TrimSuffix(string(x), string(y))" "S"
)
multiply:keys!+(
  "B" "B" "int64(x) * int64(y)" "I"
  "B" "I" "int64(x) * y" "I"
  "B" "F" "float64(x) * y" "F"
  "B" "S" "srepeat(y, int64(x))" "S"
  "I" "B" "x * int64(y)" "I"
  "I" "I" "x * y" "I"
  "I" "F" "float64(x) * y" "F"
  "I" "S" "srepeat(y, x)" "S"
  "F" "B" "x * float64(y)" "F"
  "F" "I" "x * float64(y)" "F"
  "F" "F" "x * y" "F"
  "F" "S" "srepeat(y, int64(x))" "S"
  "S" "B" "srepeat(x, int64(y))" "S"
  "S" "I" "srepeat(x, y)" "S"
  "S" "F" "srepeat(x, int64(y))" "S"
)
divide:keys!+(
  "B" "B" "divideF(float64(x), float64(y))" "F"
  "B" "I" "divideF(float64(x), float64(y))" "F"
  "B" "F" "divideF(float64(x), y)" "F"
  "I" "B" "divideF(float64(x), float64(y))" "F"
  "I" "I" "divideF(float64(x), float64(y))" "F"
  "I" "F" "divideF(float64(x), y)" "F"
  "F" "B" "divideF(x, float64(y))" "F"
  "F" "I" "divideF(x, float64(y))" "F"
  "F" "F" "divideF(x, y)" "F"
)
minimum:keys!+(
  "B" "B" "minB(x,y)" "B"
  "B" "I" "minI(int64(x), y)" "I"
  "B" "F" "math.Min(float64(x), y)" "F"
  "I" "B" "minI(x, int64(y))" "I"
  "I" "I" "minI(x, y)" "I"
  "I" "F" "math.Min(float64(x), y)" "F"
  "F" "B" "math.Min(x, float64(y))" "F"
  "F" "I" "math.Min(x, float64(y))" "F"
  "F" "F" "math.Min(x, float64(y))" "F"
  "S" "S" "minS(x, y)" "S"
)
maximum:keys!+(
  "B" "B" "maxB(x,y)" "B"
  "B" "I" "maxI(int64(x), y)" "I"
  "B" "F" "math.Max(float64(x), y)" "F"
  "I" "B" "maxI(x, int64(y))" "I"
  "I" "I" "maxI(x, y)" "I"
  "I" "F" "math.Max(float64(x), y)" "F"
  "F" "B" "math.Max(x, float64(y))" "F"
  "F" "I" "math.Max(x, float64(y))" "F"
  "F" "F" "math.Max(x, float64(y))" "F"
  "S" "S" "maxS(x, y)" "S"
)
modulus:keys!+(
  "B" "B" "modI(int64(x), int64(y))" "I"
  "B" "I" "modI(int64(x), y)" "I"
  "B" "F" "modF(float64(x), y)" "F"
  "I" "B" "modI(x, int64(y))" "I"
  "I" "I" "modI(x, y)" "I"
  "I" "F" "modF(float64(x), y)" "F"
  "F" "B" "modF(x, float64(y))" "F"
  "F" "I" "modF(x, float64(y))" "F"
  "F" "F" "modF(x, y)" "F"
)
arctan2:keys!+(
  "B" "B" "math.Atan2(float64(y), float64(x))" "F"
  "B" "I" "math.Atan2(float64(y), float64(x))" "F"
  "B" "F" "math.Atan2(y, float64(x))" "F"
  "I" "B" "math.Atan2(float64(y), float64(x))" "F"
  "I" "I" "math.Atan2(float64(y), float64(x))" "F"
  "I" "F" "math.Atan2(y, float64(x))" "F"
  "F" "B" "math.Atan2(float64(y), x)" "F"
  "F" "I" "math.Atan2(float64(y), x)" "F"
  "F" "F" "math.Atan2(y, x)" "F"
)

ops:(
  "equal" "="
  "lesser" "<"
  "greater" ">"
  "add" "+"
  "subtract" "-"
  "multiply" "*"
  "divide" "%"
  "minimum" "&"
  "maximum" "|"
  "modulus" " mod "
  "arctan2" " atan "
)

cmps:"=" "<" ">"
types:"B" "F" "I" "S" / atom types
ntypes:"B" "F" "I" / numeric atom types
itypes:"B" "I" / integer atom types
gotypes:"byte" "float64" "int64" "string" / concrete types
gontypes:"byte" "float64" "int64" "S" / concrete numeric types
utypes:"F" "I" / atom unboxed types
t2go:types!gotypes / type to concrete go type
nt2go:types!gontypes / type to concrete go type
olts:{?x["xt"]} / operator x left types
orts:{?x["yt"][&x["xt"]=y]} / operator x right types for left type y
getET:{x["expr" "rt"][;*&(x["xt"]=xt)&x["yt"]=y]} / expression and ret type for type couple
escp:sub["%";"%%"] / percent escape
doExpr:{[e;yt;x;y]
  e:?[~xt in ntypes;sub[rx/(!x|\bx)\b/;xt+`($1)`]e;e]
  e:?[~yt in ntypes;sub[rx/(!x|\by)\b/;yt+`($1)`]e;e]
  sub[rx/\by\b/;y]sub[rx/\bx\b/;x]e
}
rmbl:sub[rx/\n\s*\n/;"\n"]

genOp:{[opname;opsym] / globals o,op,xt,h
  o::opname; op::opsym; ts:olts[::o]
  h say "\n"_qq|
    // $o returns x${op}y.
    func $o(x, y V) V {|
  h say'{"if x.Is$x() { return $o${x}V(x.$x(), y) }"}'utypes#ts
  h say `switch xv := x.value.(type) {`
  h say'{"  case $x: return $o${x}V(xv, y)"}'^(ntypes^ts)
  h say'{"  case *$x: return $o${x}V(xv, y)"}'^"A"+ts
  fmtop:escp op
  h say "\n"_qq/
    case *AV:
        switch yv := y.value.(type) {
        case *Dict:
              v := $o(x, NewV(yv.values))
              if v.IsPanic() {
                      return v
              }
              v.InitRC()
              return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
        case array:
              if yv.Len() != xv.Len() {
                      return panicLength("x${op}y", xv.Len(), yv.Len())
              }/
  tplAV:{[yi]"\n"_qq/
    r := xv.reuse()
    for i, xi := range xv.elts {
            ri := $o(xi, $yi)
            if ri.IsPanic() {
                    return ri
            }
            r.elts[i] = ri
    }
    return NewV(r)/}
  h say tplAV["yv.at(i)"]
  h say `}`
  h say tplAV["y"]
  h say "\n"_qq/
    case *Dict:
        yv, ok := y.value.(*Dict)
        if ok {
            r := dictArith(xv, yv, $o)
            if r.IsPanic() {
                    return ppanic("d${op}d", r)
            }
            return r
        }
        v := $o(NewV(xv.values), y)
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: xv.keys, values: v.value.(array)})
    default:
          return panicType("x${op}y", "x", x)
    }
  }
  /
  dox'^(,"B")^ts / cases with atom x
  doX'^ts        / cases with array x
}

dox:{
  xt::x; rts:orts[::o;xt]; xct:nt2go xt
  xUy:"\n"/{(e;t):getET[::o;x];doxUy[x;e;t]}'多[;utypes]#rts
  xBy:"\n"/{(e;t):getET[::o;x];doxBy[x;e;t]}'^ntypes^rts
  xY:"\n"/{(e;t):getET[::o;x];doxY[x;e;t]}'^rts
  xdAV:doxdAV""
  h say rmbl "\n"_qq/
    func $o${xt}V(x $xct, y V) V {
        $xUy
        switch yv := y.value.(type) {
        $xBy
        $xY
        $xdAV
        }
    }
    /
}
doxUy:{[yt;e;t]
  e:?[t~"B";"int64($e)";e]
  e:sub[rx/\by\b/;"y.$yt()"]e
  t:?[t~"B";"I";t]
  e:?[t in utypes;"New$t($e)";"NewV($t($e))"]
  "if y.Is$yt() { return $e; }"
}
doxBy:{[yt;e;t]
  e:?[t~"B";"int64($e)";e]
  nt:?[t in itypes;"I";t~"F";"F";"V"]
  e:doExpr[e;yt;"x";"yv"]
  t:nt2go t
  t:?[t~"byte";"int64";t]
  "  case $yt: return New$nt($t($e))"
}
doxY:{[yt;e;t]
  e:doExpr[e;yt;"x";"yi"]
  rt:t2go t
  rs:?[yt~t;"yv.reuse()";"&A${t}{elts: make([]$rt, yv.Len()), rc: reuseRCp(yv.rc)}"]
  rs:?[op多cmps;"$rs; r.flags |= flagBool";rs]
  / TODO: add flagBool in & and | when possible
  "\n"_qq/
    case *A$yt:
        r := $rs
        for i, yi := range yv.elts {
                r.elts[i] = $rt($e)
        }
        return NewV(r)/
}
doxdAV:{
  "\n"_qq/
    case *Dict:
        v := $o${xt}V(x, NewV(yv.values))
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
        r := yv.reuse()
        for i, yi := range yv.elts {
                ri := $o${xt}V(x, yi)
                if ri.IsPanic() {
                        return ri
                }
                r.elts[i] = ri
        }
        return NewV(r)
    default:
        return panicType("x${op}y", "y", y)/
}

doX:{
  xt::x; rts:orts[::o;xt]; xct:t2go xt
  XUy:"\n"/{(e;t):getET[::o;x];doXUy[x;e;t]}'多[;utypes]#rts
  XBy:"\n"/{(e;t):getET[::o;x];doXBy[x;e;t]}'^ntypes^rts
  XY:"\n"/{(e;t):getET[::o;x];doXY[x;e;t]}'^rts
  XdAV:doXdAV""
  h say rmbl "\n"_qq/
    func ${o}A${xt}V(x *A${xt}, y V) V {
        $XUy
        switch yv := y.value.(type) {
        $XBy
        $XY
        $XdAV
        }
    }
    /
}
doXUy:{[yt;e;t]
  e:doExpr[e;t2go yt;"xi";qq/y.$yt()/]
  rt:t2go t
  rs:?[xt~t;"x.reuse()";"&A${t}{elts: make([]$rt, x.Len()), rc: reuseRCp(x.rc)}"]
  rs:?[op多cmps;"$rs; r.flags |= flagBool";rs]
  / TODO: add flagBool in & and | when possible
  "\n"_qq/
      if y.Is$yt() {
          r := $rs
          for i, xi := range x.elts {
                  r.elts[i] = $rt($e)
          }
          return NewV(r)
      }/
}
doXBy:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv"]
  rt:t2go t
  rs:?[xt~t;"x.reuse()";"&A${t}{elts: make([]$rt, x.Len()), rc: reuseRCp(x.rc)}"]
  / currently, yt~"S" in thoses cases
  "\n"_qq/
      case $yt:
              r := $rs
              for i := range r.elts {
                      r.elts[i] = $rt($e)
              }
              return NewV(r)/
}
doXY:{[yt;e;t]
  e:doExpr[e;yt;"xi";"yv.At(i)"]
  rt:t2go t
  fmtop:escp op
  s1:"\n"_qq/
    case *A$yt:
            if x.Len() != yv.Len() {
                    return panicLength("x${op}y", x.Len(), yv.Len())
            }/
  xy:?[xt~t;"x";"yv"]
  rs:?[t多xt,yt;"r := ${xy}.reuse()";"r := &A${t}{elts: make([]$rt, yv.Len()), rc: reuseRCp(x.rc)}"]
  rs:?[op多cmps;"$rs; r.flags |= flagBool";rs]
  rs:?[and[op多"&""|";xt~"B";yt~"B"]
          qq/b := x.IsBoolean() && yv.IsBoolean(); $rs
          if b {
                for i, xi := range x.elts {
                        r.elts[i] = xi $op yv.At(i)
                }
                r.flags |= flagBool
                return NewV(r)
          }
          /
          rs]
  s2:"\n"_qq/
          $rs
          for i, xi := range x.elts {
                  r.elts[i] = $rt($e)
          }
          return NewV(r)/
  "\n"/(s1;s2)
}
doXdAV:{
  nxt:?[xt~"B";"I";xt]
  xct:?[xt~"B";"int64";xt~"I";"int64";xt~"F";"float64";xt]
  fmtop:escp op
  "\n"_qq/
    case *Dict:
            v := ${o}A${xt}V(x, NewV(yv.values))
            if v.IsPanic() {
                    return v
            }
            v.InitRC()
            return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
            if x.Len() != yv.Len() {
                    return panicLength("x${op}y", x.Len(), yv.Len())
            }
            r := yv.reuse()
            for i := range r.elts {
                    ri := $o${nxt}V($xct(x.At(i)), yv.At(i))
                    if ri.IsPanic() {
                            return ri
                    }
                    r.elts[i] = ri
            }
            return NewV(r)
    default:
            return panicType("x${op}y", "y", y)/
}

'h:"w" open "../arithd.go"
h say package
{genOp . x}'ops
'close h
'run "gofmt" "-s" "-w" "../arithd.go"

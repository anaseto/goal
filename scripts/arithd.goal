package:"\n"_`
// Code generated by scripts/arithd.pl. DO NOT EDIT.

package goal

import (
    "math"
    "strings"
)
`
/ Line format: xt yt expr rt
equal:(
  "B" "B" "x == y" "B"
  "B" "I" "b2i(x) == y" "B"
  "B" "F" "b2f(x) == y" "B"
  "I" "B" "x == b2i(y)" "B"
  "I" "I" "x == y" "B"
  "I" "F" "float64(x) == y" "B"
  "F" "B" "x == b2f(y)" "B"
  "F" "I" "x == float64(y)" "B"
  "F" "F" "x == y" "B"
  "S" "S" "x == y" "B"
)
lesser:(
  "B" "B" "!x && y" "B"
  "B" "I" "b2i(x) < y" "B"
  "B" "F" "b2f(x) < y" "B"
  "I" "B" "x < b2i(y)" "B"
  "I" "I" "x < y" "B"
  "I" "F" "float64(x) < y" "B"
  "F" "B" "x < b2f(y)" "B"
  "F" "I" "x < float64(y)" "B"
  "F" "F" "x < y" "B"
  "S" "S" "x < y" "B"
)
greater:(
  "B" "B" "x && !y" "B"
  "B" "I" "b2i(x) > y" "B"
  "B" "F" "b2f(x) > y" "B"
  "I" "B" "x > b2i(y)" "B"
  "I" "I" "x > y" "B"
  "I" "F" "float64(x) > y" "B"
  "F" "B" "x > b2f(y)" "B"
  "F" "I" "x > float64(y)" "B"
  "F" "F" "x > y" "B"
  "S" "S" "x > y" "B"
)
add:(
  "B" "B" "b2i(x) + b2i(y)" "I"
  "B" "I" "b2i(x) + y" "I"
  "B" "F" "b2f(x) + y" "F"
  "I" "B" "x + b2i(y)" "I"
  "I" "I" "x + y" "I"
  "I" "F" "float64(x) + y" "F"
  "F" "B" "x + b2f(y)" "F"
  "F" "I" "x + float64(y)" "F"
  "F" "F" "x + y" "F"
  "S" "S" "x + y" "S"
)
subtract:(
  "B" "B" "b2i(x) - b2i(y)" "I"
  "B" "I" "b2i(x) - y" "I"
  "B" "F" "b2f(x) - y" "F"
  "I" "B" "x - b2i(y)" "I"
  "I" "I" "x - y" "I"
  "I" "F" "float64(x) - y" "F"
  "F" "B" "x - b2f(y)" "F"
  "F" "I" "x - float64(y)" "F"
  "F" "F" "x - y" "F"
  "S" "S" "strings.TrimSuffix(string(x), string(y))" "S"
)
multiply:(
  "B" "B" "x && y" "B"
  "B" "I" "b2i(x) * y" "I"
  "B" "F" "b2f(x) * y" "F"
  "B" "S" "srepeat(y, b2i(x))" "S"
  "I" "B" "x * b2i(y)" "I"
  "I" "I" "x * y" "I"
  "I" "F" "float64(x) * y" "F"
  "I" "S" "srepeat(y, x)" "S"
  "F" "B" "x * b2f(y)" "F"
  "F" "I" "x * float64(y)" "F"
  "F" "F" "x * y" "F"
  "F" "S" "srepeat(y, int64(x))" "S"
  "S" "B" "srepeat(x, b2i(y))" "S"
  "S" "I" "srepeat(x, y)" "S"
  "S" "F" "srepeat(x, int64(y))" "S"
)
divide:(
  "B" "B" "divideF(b2f(x), b2f(y))" "F"
  "B" "I" "divideF(b2f(x), float64(y))" "F"
  "B" "F" "divideF(b2f(x), y)" "F"
  "I" "B" "divideF(float64(x), b2f(y))" "F"
  "I" "I" "divideF(float64(x), float64(y))" "F"
  "I" "F" "divideF(float64(x), y)" "F"
  "F" "B" "divideF(x, b2f(y))" "F"
  "F" "I" "divideF(x, float64(y))" "F"
  "F" "F" "divideF(x, y)" "F"
)
minimum:(
  "B" "B" "x && y" "B"
  "B" "I" "minI(b2i(x), y)" "I"
  "B" "F" "math.Min(b2f(x), y)" "F"
  "I" "B" "minI(x, b2i(y))" "I"
  "I" "I" "minI(x, y)" "I"
  "I" "F" "math.Min(float64(x), y)" "F"
  "F" "B" "math.Min(x, b2f(y))" "F"
  "F" "I" "math.Min(x, float64(y))" "F"
  "F" "F" "math.Min(x, float64(y))" "F"
  "S" "S" "minS(x, y)" "S"
)
maximum:(
  "B" "B" "x || y" "B"
  "B" "I" "maxI(b2i(x), y)" "I"
  "B" "F" "math.Max(b2f(x), y)" "F"
  "I" "B" "maxI(x, b2i(y))" "I"
  "I" "I" "maxI(x, y)" "I"
  "I" "F" "math.Max(float64(x), y)" "F"
  "F" "B" "math.Max(x, b2f(y))" "F"
  "F" "I" "math.Max(x, float64(y))" "F"
  "F" "F" "math.Max(x, float64(y))" "F"
  "S" "S" "maxS(x, y)" "S"
)
modulus:(
  "B" "B" "modI(b2i(x), b2i(y))" "I"
  "B" "I" "modI(b2i(x), y)" "I"
  "B" "F" "modF(b2f(x), y)" "F"
  "I" "B" "modI(x, b2i(y))" "I"
  "I" "I" "modI(x, y)" "I"
  "I" "F" "modF(float64(x), y)" "F"
  "F" "B" "modF(x, b2f(y))" "F"
  "F" "I" "modF(x, float64(y))" "F"
  "F" "F" "modF(x, y)" "F"
)
types:"B" "F" "I" "S" / atom types
ntypes:"B" "F" "I" / numeric atom types
itypes:"B" "I" / integer atom types
ctypes:"bool" "float64" "int64" "string"
cntypes:"bool" "float64" "int64" "S"
utypes:"F" "I" / atom unboxed types
t2go:{ctypes[types?x]} / type to concrete go type
nt2go:{cntypes[types?x]} / type to concrete go type
olts:{?x[;0]} / operator x left types
orts:{?x[&x[;0]=y][;1]} / operator x right types for left type y
getET:{(*x[&(x[;0]=y)&x[;1]=z])[2 3]} / expression and ret type for type couple
escp:sub["%";"%%"] / percent escape
doExpr:{[e;yt;x;y]
  e:?[~xt in ntypes;sub[rx/(!x|\bb2[IF]\(x\)|\bx)\b/;xt+"($1)"]e;e]
  e:?[~yt in ntypes;sub[rx/(!x|\bb2[IF]\(y\)|\by)\b/;yt+"($1)"]e;e]
  e:sub[rx/\bx\b/;x]e
  e:sub[rx/\by\b/;y]e
}
genOp:{
  o::x; op::y; ts::olts[::o]
  say sub[("OO";o;"OP";op)] `// OO returns xOPy.`
  say sub["OO",o] `func OO(x, y V) V {`
  say'{sub[("XX";"x";"XT";x;"OO";o;"YY";"y")][
      `if XX.IsXT() { return OOXTV(XX.XT(), YY) }`
  ]}'utypes#ts
  say `switch xv := x.value.(type) {`
  say'{sub[("XT";x;"OO";o)] `  case XT: return OOXTV(xv, y)`}'^(ntypes^ts)
  say'{sub[("XT";x;"OO";o)] `  case *XT: return OOXTV(xv, y)`}'^"A"+ts
  say sub["OP";escp op]"\n"_`
  case *AV:
      switch yv := y.value.(type) {
      case array:
            if yv.Len() != xv.Len() {
                    return Panicf("xOPy : length mismatch: %d vs %d", xv.Len(), yv.Len())
            }`
  tplAV:"\n"_`
  r := xv.reuse()
  for i, xi := range xv.Slice {
          ri := OO(xi, YY)
          if ri.IsPanic() {
                  return ri
          }
          r.Slice[i] = ri
  }
  return NewV(r)`
  say sub[("OO";o;"YY";"yv.at(i)")] tplAV
  say `}`
  say sub[("OO";o;"YY";"y")] tplAV
  say sub["OP";op]"\n"_`
  default:
        return panicTypeElt("xOPy", "x", x)
  }
}
`
  dox'^(,"B")^ts
  doX'^ts
}
dox:{
  xt::x; rts:orts[::o;xt]; xct:nt2go xt
  say sub[("OO";o;"XT";xt;"XCT";xct)] `func OOXTV(x XCT, y V) V {`
  say'{(e;t):getET[::o;xt;x];doxUy[x;e;t]}'utypes#rts
  say `  switch yv := y.value.(type) {`
  say'{(e;t):getET[::o;xt;x];doxBy[x;e;t]}'^ntypes^rts
  say'{(e;t):getET[::o;xt;x];doxY[x;e;t]}'^rts
  doxAV""
  say"}\n"
}
doxUy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  e:sub[rx/\by\b/;"y."+yt+"()"]e
  t:?[t~"B";"I";t]
  e:?[t in utypes;+/("New";t;"(";e;")");+/("NewV";"(";t;"(";e;"))")]
  sub[("YT";yt;"EE";e)] `if y.IsYT() { return EE; }`
}
doxBy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  nt:?[t in itypes;"I";t~"F";"F";"V"]
  e:doExpr[e;yt;"x";"yv"]
  t:nt2go t
  t:?[t~"bool";"int64";t]
  sub[("YT";yt;"NT";nt;"RT";t;"EE";e)]`  case YT: return NewNT(RT(EE))`
}
doxY:{[yt;e;t]
  e:doExpr[e;yt;"x";"yv.At(i)"]
  rt:t2go t
  ?[yt~t
   sub[("YT";yt;"RT";rt;"EE";e)]"\n"_`
  case *AYT:
      r := yv.reuse()
      for i := range r.Slice {
              r.Slice[i] = RT(EE)
      }
      return NewV(r)`
   sub[("YT";yt;"RT";rt;"EE";e;"TT";t)]"\n"_`
  case *AYT:
      r := make([]RT, yv.Len())
      for i := range r {
              r[i] = RT(EE)
      }
      return NewATTWithRC(r, reuseRCp(yv.rc))`]
}
doxAV:{
  say sub[("OO";o;"XT";xt;"OP";op)]"\n"_`
  case *AV:
      r := yv.reuse()
      for i, yi := range yv.Slice {
              ri := OOXTV(x, yi)
              if ri.IsPanic() {
                      return ri
              }
              r.Slice[i] = ri
      }
      return NewV(r)
  default:
      return panicTypeElt("xOPy", "y", y)
  }`
}
doX:{
  xt::x; rts:orts[::o;xt]; xct:t2go xt
  say sub[("OO";o;"XT";xt)] `func OOAXTV(x *AXT, y V) V {`
  say'{(e;t):getET[::o;xt;x];doXUy[x;e;t]}'utypes#rts
  say `  switch yv := y.value.(type) {`
  say'{(e;t):getET[::o;xt;x];doXBy[x;e;t]}'^ntypes^rts
  say'{(e;t):getET[::o;xt;x];doXY[x;e;t]}'^rts
  doXAV""
}
doXUy:{[yt;e;t]
  e:doExpr[e;t2go yt;"x.At(i)";"y."+yt+"()"]
  rt:t2go t
  ?[xt~t
    sub[("YT";yt;"RT";rt;"EE";e)]"\n"_`
  if y.IsYT() {
      r := x.reuse()
      for i := range r.Slice {
              r.Slice[i] = RT(EE)
      }
      return NewV(r)
  }`
   sub[("YT";yt;"RT";rt;"EE";e;"TT";t)]"\n"_`
  if y.IsYT() {
      r := make([]RT, x.Len())
      for i := range r {
              r[i] = RT(EE)
      }
      return NewATTWithRC(r, reuseRCp(x.rc))
  }`]
}
doXBy:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv"]
  rt:t2go t
  ?[xt~t
    sub[("YT";yt;"RT";rt;"EE";e)]"\n"_`
  case YT:
          r := x.reuse()
          for i := range r.Slice {
                  r.Slice[i] = RT(EE)
          }
          return NewV(r)`
    sub[("YT";yt;"RT";rt;"EE";e;"TT";t)]"\n"_`
  case YT:
          r := make([]RT, x.Len())
          for i := range r {
                  r[i] = RT(EE)
          }
          return NewATTWithRC(r, reuseRCp(x.rc))`]
}
doXY:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv.At(i)"]
  rt:t2go t
  s1:sub[("YT";yt;"OP";escp op)]"\n"_`
  case *AYT:
          if x.Len() != yv.Len() {
                  return Panicf("xOPy : length mismatch: %d vs %d", x.Len(), yv.Len())
          }`
  s2:?[t in xt,yt
    sub[("RT";rt;"EE";e;"XY";?[xt~t;"x";"yv"])]"\n"_`
          r := XY.reuse()
          for i := range r.Slice {
                  r.Slice[i] = RT(EE)
          }
          return NewV(r)`
    sub[("RT";rt;"EE";e;"TT";t)]"\n"_`
          r := make([]RT, yv.Len())
          for i := range r {
                  r[i] = RT(EE)
          }
          return NewATTWithRC(r, reuseRCp(x.rc))`]
  "\n"/(s1;s2)
}
doXAV:{
  nxt:?[xt~"B";"I";xt]
  xct:?[xt~"B";"b2i";xt~"I";"int64";xt~"F";"float64";xt]
  reuse:?[xt~"V"
    `var r *AV
    if x.reusable() {
        r = x.reuse()
    } else {
        r = yv.reuse()
    }`
    `r := yv.reuse()`]
  say sub[("OPE";escp op;"OP";op;"OO";o;"XT";nxt;"XCT";xct;"REUSE";reuse)]"\n"_`
  case *AV:
          if x.Len() != yv.Len() {
                  return Panicf("xOPEy : length mismatch: %d vs %d", x.Len(), yv.Len())
          }
          REUSE

          for i := range r.Slice {
                  ri := OOXTV(XCT(x.At(i)), yv.At(i))
                  if ri.IsPanic() {
                          return ri
                  }
                  r.Slice[i] = ri
          }
          return NewV(r)
  default:
          return panicTypeElt("xOPy", "y", y)
  }
}
`
}
say package
genOp["equal";"="]
genOp["lesser";"<"]
genOp["greater";">"]
genOp["add";"+"]
genOp["subtract";"-"]
genOp["multiply";"*"]
genOp["divide";"%"]
genOp["minimum";"&"]
genOp["maximum";"|"]
genOp["modulus";"!"]

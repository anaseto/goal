package:"\n"_`
// Code generated by scripts/arithd.goal. DO NOT EDIT.

package goal

import (
    "math"
    "strings"
)
`

keys:"xt" "yt" "expr" "rt"
equal:keys!+(
  "B" "B" "x == y" "B"
  "B" "I" "B2I(x) == y" "B"
  "B" "F" "B2F(x) == y" "B"
  "I" "B" "x == B2I(y)" "B"
  "I" "I" "x == y" "B"
  "I" "F" "float64(x) == y" "B"
  "F" "B" "x == B2F(y)" "B"
  "F" "I" "x == float64(y)" "B"
  "F" "F" "x == y" "B"
  "S" "S" "x == y" "B"
)
lesser:keys!+(
  "B" "B" "!x && y" "B"
  "B" "I" "B2I(x) < y" "B"
  "B" "F" "B2F(x) < y" "B"
  "I" "B" "x < B2I(y)" "B"
  "I" "I" "x < y" "B"
  "I" "F" "float64(x) < y" "B"
  "F" "B" "x < B2F(y)" "B"
  "F" "I" "x < float64(y)" "B"
  "F" "F" "x < y" "B"
  "S" "S" "x < y" "B"
)
greater:keys!+(
  "B" "B" "x && !y" "B"
  "B" "I" "B2I(x) > y" "B"
  "B" "F" "B2F(x) > y" "B"
  "I" "B" "x > B2I(y)" "B"
  "I" "I" "x > y" "B"
  "I" "F" "float64(x) > y" "B"
  "F" "B" "x > B2F(y)" "B"
  "F" "I" "x > float64(y)" "B"
  "F" "F" "x > y" "B"
  "S" "S" "x > y" "B"
)
add:keys!+(
  "B" "B" "B2I(x) + B2I(y)" "I"
  "B" "I" "B2I(x) + y" "I"
  "B" "F" "B2F(x) + y" "F"
  "I" "B" "x + B2I(y)" "I"
  "I" "I" "x + y" "I"
  "I" "F" "float64(x) + y" "F"
  "F" "B" "x + B2F(y)" "F"
  "F" "I" "x + float64(y)" "F"
  "F" "F" "x + y" "F"
  "S" "S" "x + y" "S"
)
subtract:keys!+(
  "B" "B" "B2I(x) - B2I(y)" "I"
  "B" "I" "B2I(x) - y" "I"
  "B" "F" "B2F(x) - y" "F"
  "I" "B" "x - B2I(y)" "I"
  "I" "I" "x - y" "I"
  "I" "F" "float64(x) - y" "F"
  "F" "B" "x - B2F(y)" "F"
  "F" "I" "x - float64(y)" "F"
  "F" "F" "x - y" "F"
  "S" "S" "strings.TrimSuffix(string(x), string(y))" "S"
)
multiply:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "B2I(x) * y" "I"
  "B" "F" "B2F(x) * y" "F"
  "B" "S" "srepeat(y, B2I(x))" "S"
  "I" "B" "x * B2I(y)" "I"
  "I" "I" "x * y" "I"
  "I" "F" "float64(x) * y" "F"
  "I" "S" "srepeat(y, x)" "S"
  "F" "B" "x * B2F(y)" "F"
  "F" "I" "x * float64(y)" "F"
  "F" "F" "x * y" "F"
  "F" "S" "srepeat(y, int64(x))" "S"
  "S" "B" "srepeat(x, B2I(y))" "S"
  "S" "I" "srepeat(x, y)" "S"
  "S" "F" "srepeat(x, int64(y))" "S"
)
divide:keys!+(
  "B" "B" "divideF(B2F(x), B2F(y))" "F"
  "B" "I" "divideF(B2F(x), float64(y))" "F"
  "B" "F" "divideF(B2F(x), y)" "F"
  "I" "B" "divideF(float64(x), B2F(y))" "F"
  "I" "I" "divideF(float64(x), float64(y))" "F"
  "I" "F" "divideF(float64(x), y)" "F"
  "F" "B" "divideF(x, B2F(y))" "F"
  "F" "I" "divideF(x, float64(y))" "F"
  "F" "F" "divideF(x, y)" "F"
)
minimum:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "minI(B2I(x), y)" "I"
  "B" "F" "math.Min(B2F(x), y)" "F"
  "I" "B" "minI(x, B2I(y))" "I"
  "I" "I" "minI(x, y)" "I"
  "I" "F" "math.Min(float64(x), y)" "F"
  "F" "B" "math.Min(x, B2F(y))" "F"
  "F" "I" "math.Min(x, float64(y))" "F"
  "F" "F" "math.Min(x, float64(y))" "F"
  "S" "S" "minS(x, y)" "S"
)
maximum:keys!+(
  "B" "B" "x || y" "B"
  "B" "I" "maxI(B2I(x), y)" "I"
  "B" "F" "math.Max(B2F(x), y)" "F"
  "I" "B" "maxI(x, B2I(y))" "I"
  "I" "I" "maxI(x, y)" "I"
  "I" "F" "math.Max(float64(x), y)" "F"
  "F" "B" "math.Max(x, B2F(y))" "F"
  "F" "I" "math.Max(x, float64(y))" "F"
  "F" "F" "math.Max(x, float64(y))" "F"
  "S" "S" "maxS(x, y)" "S"
)
modulus:keys!+(
  "B" "B" "modI(B2I(x), B2I(y))" "I"
  "B" "I" "modI(B2I(x), y)" "I"
  "B" "F" "modF(B2F(x), y)" "F"
  "I" "B" "modI(x, B2I(y))" "I"
  "I" "I" "modI(x, y)" "I"
  "I" "F" "modF(float64(x), y)" "F"
  "F" "B" "modF(x, B2F(y))" "F"
  "F" "I" "modF(x, float64(y))" "F"
  "F" "F" "modF(x, y)" "F"
)

ops:(
  "equal" "="
  "lesser" "<"
  "greater" ">"
  "add" "+"
  "subtract" "-"
  "multiply" "*"
  "divide" "%"
  "minimum" "&"
  "maximum" "|"
  "modulus" " mod "
)

types:"B" "F" "I" "S" / atom types
ntypes:"B" "F" "I" / numeric atom types
itypes:"B" "I" / integer atom types
gotypes:"bool" "float64" "int64" "string" / concrete types
gontypes:"bool" "float64" "int64" "S" / concrete numeric types
utypes:"F" "I" / atom unboxed types
t2go:types!gotypes / type to concrete go type
nt2go:types!gontypes / type to concrete go type
olts:{?x["xt"]} / operator x left types
orts:{?x["yt"][&x["xt"]=y]} / operator x right types for left type y
getET:{x["expr" "rt"][;*&(x["xt"]=xt)&x["yt"]=y]} / expression and ret type for type couple
escp:sub["%";"%%"] / percent escape
doExpr:{[e;yt;x;y]
  e:?[~xt in ntypes;sub[rx/(!x|\bx)\b/;xt+`($1)`]e;e]
  e:?[~yt in ntypes;sub[rx/(!x|\by)\b/;yt+`($1)`]e;e]
  sub[rx/\by\b/;y]sub[rx/\bx\b/;x]e
}
rmbl:sub[rx/\n\s*\n/;"\n"]

genOp:{[opname;opsym] / globals o,op,xt,h
  o::opname; op::opsym; ts:olts[::o]
  h say "\n"_qq|
    // $o returns x${op}y.
    func $o(x, y V) V {|
  h say'{"if x.Is$x() { return $o${x}V(x.$x(), y) }"}'utypes#ts
  h say `switch xv := x.value.(type) {`
  h say'{"  case $x: return $o${x}V(xv, y)"}'^(ntypes^ts)
  h say'{"  case *$x: return $o${x}V(xv, y)"}'^"A"+ts
  fmtop:escp op
  h say "\n"_qq/
    case *AV:
        switch yv := y.value.(type) {
        case *Dict:
              v := $o(x, NewV(yv.values))
              if v.IsPanic() {
                      return v
              }
              v.InitRC()
              return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
        case array:
              if yv.Len() != xv.Len() {
                      return Panicf("x${fmtop}y : length mismatch: %d vs %d", xv.Len(), yv.Len())
              }/
  tplAV:{[yi]"\n"_qq/
    r := xv.reuse()
    for i, xi := range xv.Slice {
            ri := $o(xi, $yi)
            if ri.IsPanic() {
                    return ri
            }
            r.Slice[i] = ri
    }
    return NewV(r)/}
  h say tplAV["yv.at(i)"]
  h say `}`
  h say tplAV["y"]
  h say "\n"_qq/
    case *Dict:
        yv, ok := y.value.(*Dict)
        if ok {
            r := dictArith(xv, yv, $o)
            if r.IsPanic() {
                    return ppanic("d${op}d", r)
            }
            return r
        }
        v := $o(NewV(xv.values), y)
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: xv.keys, values: v.value.(array)})
    default:
          return panicTypeElt("x${op}y", "x", x)
    }
  }
  /
  dox'^(,"B")^ts / cases with atom x
  doX'^ts        / cases with array x
}

dox:{
  xt::x; rts:orts[::o;xt]; xct:nt2go xt
  xUy:"\n"/{(e;t):getET[::o;x];doxUy[x;e;t]}'utypes#rts
  xBy:"\n"/{(e;t):getET[::o;x];doxBy[x;e;t]}'^ntypes^rts
  xY:"\n"/{(e;t):getET[::o;x];doxY[x;e;t]}'^rts
  xdAV:doxdAV""
  h say rmbl "\n"_qq/
    func $o${xt}V(x $xct, y V) V {
        $xUy
        switch yv := y.value.(type) {
        $xBy
        $xY
        $xdAV
        }
    }
    /
}
doxUy:{[yt;e;t]
  e:?[t~"B";"B2I($e)";e]
  e:sub[rx/\by\b/;"y.$yt()"]e
  t:?[t~"B";"I";t]
  e:?[t in utypes;"New$t($e)";"NewV($t($e))"]
  "if y.Is$yt() { return $e; }"
}
doxBy:{[yt;e;t]
  e:?[t~"B";qq/B2I($e)/;e]
  nt:?[t in itypes;"I";t~"F";"F";"V"]
  e:doExpr[e;yt;"x";"yv"]
  t:nt2go t
  t:?[t~"bool";"int64";t]
  "  case $yt: return New$nt($t($e))"
}
doxY:{[yt;e;t]
  e:doExpr[e;yt;"x";"yv.At(i)"]
  rt:t2go t
  ?[yt~t
   "\n"_qq/
    case *A$yt:
        r := yv.reuse()
        for i := range r.Slice {
                r.Slice[i] = $rt($e)
        }
        return NewV(r)/
   "\n"_qq/
    case *A$yt:
        r := make([]$rt, yv.Len())
        for i := range r {
                r[i] = $rt($e)
        }
        return NewA${t}WithRC(r, reuseRCp(yv.rc))/]
}
doxdAV:{
  "\n"_qq/
    case *Dict:
        v := $o${xt}V(x, NewV(yv.values))
        if v.IsPanic() {
                return v
        }
        v.InitRC()
        return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
        r := yv.reuse()
        for i, yi := range yv.Slice {
                ri := $o${xt}V(x, yi)
                if ri.IsPanic() {
                        return ri
                }
                r.Slice[i] = ri
        }
        return NewV(r)
    default:
        return panicTypeElt("x${op}y", "y", y)/
}

doX:{
  xt::x; rts:orts[::o;xt]; xct:t2go xt
  XUy:"\n"/{(e;t):getET[::o;x];doXUy[x;e;t]}'utypes#rts
  XBy:"\n"/{(e;t):getET[::o;x];doXBy[x;e;t]}'^ntypes^rts
  XY:"\n"/{(e;t):getET[::o;x];doXY[x;e;t]}'^rts
  XdAV:doXdAV""
  h say rmbl "\n"_qq/
    func ${o}A${xt}V(x *A${xt}, y V) V {
        $XUy
        switch yv := y.value.(type) {
        $XBy
        $XY
        $XdAV
        }
    }
    /
}
doXUy:{[yt;e;t]
  e:doExpr[e;t2go yt;"x.At(i)";qq/y.$yt()/]
  rt:t2go t
  ?[xt~t
    "\n"_qq/
      if y.Is$yt() {
          r := x.reuse()
          for i := range r.Slice {
                  r.Slice[i] = $rt($e)
          }
          return NewV(r)
      }/
   "\n"_qq/
      if y.Is$yt() {
          r := make([]$rt, x.Len())
          for i := range r {
                  r[i] = $rt($e)
          }
          return NewA${t}WithRC(r, reuseRCp(x.rc))
      }/]
}
doXBy:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv"]
  rt:t2go t
  ?[xt~t
    "\n"_qq/
      case $yt:
              r := x.reuse()
              for i := range r.Slice {
                      r.Slice[i] = $rt($e)
              }
              return NewV(r)/
    "\n"_qq/
      case $yt:
              r := make([]$rt, x.Len())
              for i := range r {
                      r[i] = $rt($e)
              }
              return NewA${t}WithRC(r, reuseRCp(x.rc))/]
}
doXY:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv.At(i)"]
  rt:t2go t
  fmtop:escp op
  s1:"\n"_qq/
    case *A$yt:
            if x.Len() != yv.Len() {
                    return Panicf("x${fmtop}y : length mismatch: %d vs %d", x.Len(), yv.Len())
            }/
  s2:?[t in xt,yt
    sub["{XY}";?[xt~t;"x";"yv"]]"\n"_qq/
          r := {XY}.reuse()
          for i := range r.Slice {
                  r.Slice[i] = $rt($e)
          }
          return NewV(r)/
    "\n"_qq/
          r := make([]$rt, yv.Len())
          for i := range r {
                  r[i] = $rt($e)
          }
          return NewA${t}WithRC(r, reuseRCp(x.rc))/]
  "\n"/(s1;s2)
}
doXdAV:{
  nxt:?[xt~"B";"I";xt]
  xct:?[xt~"B";"B2I";xt~"I";"int64";xt~"F";"float64";xt]
  fmtop:escp op
  "\n"_qq/
    case *Dict:
            v := ${o}A${xt}V(x, NewV(yv.values))
            if v.IsPanic() {
                    return v
            }
            v.InitRC()
            return NewV(&Dict{keys: yv.keys, values: v.value.(array)})
    case *AV:
            if x.Len() != yv.Len() {
                    return Panicf("x${fmtop}y : length mismatch: %d vs %d", x.Len(), yv.Len())
            }
            r := yv.reuse()
            for i := range r.Slice {
                    ri := $o${nxt}V($xct(x.At(i)), yv.At(i))
                    if ri.IsPanic() {
                            return ri
                    }
                    r.Slice[i] = ri
            }
            return NewV(r)
    default:
            return panicTypeElt("x${op}y", "y", y)/
}

'h:"w" open "../arithd.go"
h say package
{genOp . x}'ops
'close h
'run "gofmt" "-s" "-w" "../arithd.go"

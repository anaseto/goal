package:"\n"_`
// Code generated by scripts/arithd.goal. DO NOT EDIT.

package goal

import (
    "math"
    "strings"
)
`

keys:"xt" "yt" "expr" "rt"
equal:keys!+(
  "B" "B" "x == y" "B"
  "B" "I" "b2i(x) == y" "B"
  "B" "F" "b2f(x) == y" "B"
  "I" "B" "x == b2i(y)" "B"
  "I" "I" "x == y" "B"
  "I" "F" "float64(x) == y" "B"
  "F" "B" "x == b2f(y)" "B"
  "F" "I" "x == float64(y)" "B"
  "F" "F" "x == y" "B"
  "S" "S" "x == y" "B"
)
lesser:keys!+(
  "B" "B" "!x && y" "B"
  "B" "I" "b2i(x) < y" "B"
  "B" "F" "b2f(x) < y" "B"
  "I" "B" "x < b2i(y)" "B"
  "I" "I" "x < y" "B"
  "I" "F" "float64(x) < y" "B"
  "F" "B" "x < b2f(y)" "B"
  "F" "I" "x < float64(y)" "B"
  "F" "F" "x < y" "B"
  "S" "S" "x < y" "B"
)
greater:keys!+(
  "B" "B" "x && !y" "B"
  "B" "I" "b2i(x) > y" "B"
  "B" "F" "b2f(x) > y" "B"
  "I" "B" "x > b2i(y)" "B"
  "I" "I" "x > y" "B"
  "I" "F" "float64(x) > y" "B"
  "F" "B" "x > b2f(y)" "B"
  "F" "I" "x > float64(y)" "B"
  "F" "F" "x > y" "B"
  "S" "S" "x > y" "B"
)
add:keys!+(
  "B" "B" "b2i(x) + b2i(y)" "I"
  "B" "I" "b2i(x) + y" "I"
  "B" "F" "b2f(x) + y" "F"
  "I" "B" "x + b2i(y)" "I"
  "I" "I" "x + y" "I"
  "I" "F" "float64(x) + y" "F"
  "F" "B" "x + b2f(y)" "F"
  "F" "I" "x + float64(y)" "F"
  "F" "F" "x + y" "F"
  "S" "S" "x + y" "S"
)
subtract:keys!+(
  "B" "B" "b2i(x) - b2i(y)" "I"
  "B" "I" "b2i(x) - y" "I"
  "B" "F" "b2f(x) - y" "F"
  "I" "B" "x - b2i(y)" "I"
  "I" "I" "x - y" "I"
  "I" "F" "float64(x) - y" "F"
  "F" "B" "x - b2f(y)" "F"
  "F" "I" "x - float64(y)" "F"
  "F" "F" "x - y" "F"
  "S" "S" "strings.TrimSuffix(string(x), string(y))" "S"
)
multiply:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "b2i(x) * y" "I"
  "B" "F" "b2f(x) * y" "F"
  "B" "S" "srepeat(y, b2i(x))" "S"
  "I" "B" "x * b2i(y)" "I"
  "I" "I" "x * y" "I"
  "I" "F" "float64(x) * y" "F"
  "I" "S" "srepeat(y, x)" "S"
  "F" "B" "x * b2f(y)" "F"
  "F" "I" "x * float64(y)" "F"
  "F" "F" "x * y" "F"
  "F" "S" "srepeat(y, int64(x))" "S"
  "S" "B" "srepeat(x, b2i(y))" "S"
  "S" "I" "srepeat(x, y)" "S"
  "S" "F" "srepeat(x, int64(y))" "S"
)
divide:keys!+(
  "B" "B" "divideF(b2f(x), b2f(y))" "F"
  "B" "I" "divideF(b2f(x), float64(y))" "F"
  "B" "F" "divideF(b2f(x), y)" "F"
  "I" "B" "divideF(float64(x), b2f(y))" "F"
  "I" "I" "divideF(float64(x), float64(y))" "F"
  "I" "F" "divideF(float64(x), y)" "F"
  "F" "B" "divideF(x, b2f(y))" "F"
  "F" "I" "divideF(x, float64(y))" "F"
  "F" "F" "divideF(x, y)" "F"
)
minimum:keys!+(
  "B" "B" "x && y" "B"
  "B" "I" "minI(b2i(x), y)" "I"
  "B" "F" "math.Min(b2f(x), y)" "F"
  "I" "B" "minI(x, b2i(y))" "I"
  "I" "I" "minI(x, y)" "I"
  "I" "F" "math.Min(float64(x), y)" "F"
  "F" "B" "math.Min(x, b2f(y))" "F"
  "F" "I" "math.Min(x, float64(y))" "F"
  "F" "F" "math.Min(x, float64(y))" "F"
  "S" "S" "minS(x, y)" "S"
)
maximum:keys!+(
  "B" "B" "x || y" "B"
  "B" "I" "maxI(b2i(x), y)" "I"
  "B" "F" "math.Max(b2f(x), y)" "F"
  "I" "B" "maxI(x, b2i(y))" "I"
  "I" "I" "maxI(x, y)" "I"
  "I" "F" "math.Max(float64(x), y)" "F"
  "F" "B" "math.Max(x, b2f(y))" "F"
  "F" "I" "math.Max(x, float64(y))" "F"
  "F" "F" "math.Max(x, float64(y))" "F"
  "S" "S" "maxS(x, y)" "S"
)
modulus:keys!+(
  "B" "B" "modI(b2i(x), b2i(y))" "I"
  "B" "I" "modI(b2i(x), y)" "I"
  "B" "F" "modF(b2f(x), y)" "F"
  "I" "B" "modI(x, b2i(y))" "I"
  "I" "I" "modI(x, y)" "I"
  "I" "F" "modF(float64(x), y)" "F"
  "F" "B" "modF(x, b2f(y))" "F"
  "F" "I" "modF(x, float64(y))" "F"
  "F" "F" "modF(x, y)" "F"
)

types:"B" "F" "I" "S" / atom types
ntypes:"B" "F" "I" / numeric atom types
itypes:"B" "I" / integer atom types
gotypes:"bool" "float64" "int64" "string" / concrete types
gontypes:"bool" "float64" "int64" "S" / concrete numeric types
utypes:"F" "I" / atom unboxed types
t2go:types!gotypes / type to concrete go type
nt2go:types!gontypes / type to concrete go type
olts:{?x["xt"]} / operator x left types
orts:{?x["yt"][&x["xt"]=y]} / operator x right types for left type y
getET:{x["expr" "rt"][;*&(x["xt"]=y)&x["yt"]=z]} / expression and ret type for type couple
escp:sub["%";"%%"] / percent escape
doExpr:{[e;yt;x;y]
  e:?[~xt in ntypes;sub[rx/(!x|\bx)\b/;xt+"($1)"]e;e]
  e:?[~yt in ntypes;sub[rx/(!x|\by)\b/;yt+"($1)"]e;e]
  sub[rx/\by\b/;y]sub[rx/\bx\b/;x]e
}

genOp:{[opname;opsym] / globals o,op,xt
  o::opname; op::opsym; ts:olts[::o]
  say sub[("{OO}";o;"{OP}";op)] `// {OO} returns x{OP}y.`
  say sub["{OO}",o] `func {OO}(x, y V) V {`
  say'{sub[("{XT}";x;"{OO}";o)][
      `if x.Is{XT}() { return {OO}{XT}V(x.{XT}(), y) }`
  ]}'utypes#ts
  say `switch xv := x.value.(type) {`
  say'{sub[("{XT}";x;"{OO}";o)] `  case {XT}: return {OO}{XT}V(xv, y)`}'^(ntypes^ts)
  say'{sub[("{XT}";x;"{OO}";o)] `  case *{XT}: return {OO}{XT}V(xv, y)`}'^"A"+ts
  say sub["{OP}";escp op]"\n"_`
  case *AV:
      switch yv := y.value.(type) {
      case array:
            if yv.Len() != xv.Len() {
                    return Panicf("x{OP}y : length mismatch: %d vs %d", xv.Len(), yv.Len())
            }`
  tplAV:"\n"_`
  r := xv.reuse()
  for i, xi := range xv.Slice {
          ri := {OO}(xi, {YY})
          if ri.IsPanic() {
                  return ri
          }
          r.Slice[i] = ri
  }
  return NewV(r)`
  say sub[("{OO}";o;"{YY}";"yv.at(i)")] tplAV
  say `}`
  say sub[("{OO}";o;"{YY}";"y")] tplAV
  say sub["{OP}";op]"\n"_`
  default:
        return panicTypeElt("x{OP}y", "x", x)
  }
}
`
  dox'^(,"B")^ts / cases with atom x
  doX'^ts        / cases with array x
}

dox:{
  xt::x; rts:orts[::o;xt]; xct:nt2go xt
  say sub[("{OO}";o;"{XT}";xt;"{XCT}";xct)] `func {OO}{XT}V(x {XCT}, y V) V {`
  say'{(e;t):getET[::o;xt;x];doxUy[x;e;t]}'utypes#rts
  say `  switch yv := y.value.(type) {`
  say'{(e;t):getET[::o;xt;x];doxBy[x;e;t]}'^ntypes^rts
  say'{(e;t):getET[::o;xt;x];doxY[x;e;t]}'^rts
  say doxAV""
  say"}\n"
}
doxUy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  e:sub[rx/\by\b/;"y."+yt+"()"]e
  t:?[t~"B";"I";t]
  e:?[t in utypes;+/("New";t;"(";e;")");+/("NewV";"(";t;"(";e;"))")]
  sub[("{YT}";yt;"{EE}";e)] `if y.Is{YT}() { return {EE}; }`
}
doxBy:{[yt;e;t]
  e:?[t~"B";"b2i("+e+")";e]
  nt:?[t in itypes;"I";t~"F";"F";"V"]
  e:doExpr[e;yt;"x";"yv"]
  t:nt2go t
  t:?[t~"bool";"int64";t]
  sub[("{YT}";yt;"{NT}";nt;"{RT}";t;"{EE}";e)]`  case {YT}: return New{NT}({RT}({EE}))`
}
doxY:{[yt;e;t]
  e:doExpr[e;yt;"x";"yv.At(i)"]
  rt:t2go t
  ?[yt~t
   sub[("{YT}";yt;"{RT}";rt;"{EE}";e)]"\n"_`
  case *A{YT}:
      r := yv.reuse()
      for i := range r.Slice {
              r.Slice[i] = {RT}({EE})
      }
      return NewV(r)`
   sub[("{YT}";yt;"{RT}";rt;"{EE}";e;"{TT}";t)]"\n"_`
  case *A{YT}:
      r := make([]{RT}, yv.Len())
      for i := range r {
              r[i] = {RT}({EE})
      }
      return NewA{TT}WithRC(r, reuseRCp(yv.rc))`]
}
doxAV:{
  sub[("{OO}";o;"{XT}";xt;"{OP}";op)]"\n"_`
  case *AV:
      r := yv.reuse()
      for i, yi := range yv.Slice {
              ri := {OO}{XT}V(x, yi)
              if ri.IsPanic() {
                      return ri
              }
              r.Slice[i] = ri
      }
      return NewV(r)
  default:
      return panicTypeElt("x{OP}y", "y", y)
  }`
}

doX:{
  xt::x; rts:orts[::o;xt]; xct:t2go xt
  say sub[("{OO}";o;"{XT}";xt)] `func {OO}A{XT}V(x *A{XT}, y V) V {`
  say'{(e;t):getET[::o;xt;x];doXUy[x;e;t]}'utypes#rts
  say `  switch yv := y.value.(type) {`
  say'{(e;t):getET[::o;xt;x];doXBy[x;e;t]}'^ntypes^rts
  say'{(e;t):getET[::o;xt;x];doXY[x;e;t]}'^rts
  say doXAV""
}
doXUy:{[yt;e;t]
  e:doExpr[e;t2go yt;"x.At(i)";"y."+yt+"()"]
  rt:t2go t
  ?[xt~t
    sub[("{YT}";yt;"{RT}";rt;"{EE}";e)]"\n"_`
  if y.Is{YT}() {
      r := x.reuse()
      for i := range r.Slice {
              r.Slice[i] = {RT}({EE})
      }
      return NewV(r)
  }`
   sub[("{YT}";yt;"{RT}";rt;"{EE}";e;"{TT}";t)]"\n"_`
  if y.Is{YT}() {
      r := make([]{RT}, x.Len())
      for i := range r {
              r[i] = {RT}({EE})
      }
      return NewA{TT}WithRC(r, reuseRCp(x.rc))
  }`]
}
doXBy:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv"]
  rt:t2go t
  ?[xt~t
    sub[("{YT}";yt;"{RT}";rt;"{EE}";e)]"\n"_`
  case {YT}:
          r := x.reuse()
          for i := range r.Slice {
                  r.Slice[i] = {RT}({EE})
          }
          return NewV(r)`
    sub[("{YT}";yt;"{RT}";rt;"{EE}";e;"{TT}";t)]"\n"_`
  case {YT}:
          r := make([]{RT}, x.Len())
          for i := range r {
                  r[i] = {RT}({EE})
          }
          return NewA{TT}WithRC(r, reuseRCp(x.rc))`]
}
doXY:{[yt;e;t]
  e:doExpr[e;yt;"x.At(i)";"yv.At(i)"]
  rt:t2go t
  s1:sub[("{YT}";yt;"{OP}";escp op)]"\n"_`
  case *A{YT}:
          if x.Len() != yv.Len() {
                  return Panicf("x{OP}y : length mismatch: %d vs %d", x.Len(), yv.Len())
          }`
  s2:?[t in xt,yt
    sub[("{RT}";rt;"{EE}";e;"{XY}";?[xt~t;"x";"yv"])]"\n"_`
          r := {XY}.reuse()
          for i := range r.Slice {
                  r.Slice[i] = {RT}({EE})
          }
          return NewV(r)`
    sub[("{RT}";rt;"{EE}";e;"{TT}";t)]"\n"_`
          r := make([]{RT}, yv.Len())
          for i := range r {
                  r[i] = {RT}({EE})
          }
          return NewA{TT}WithRC(r, reuseRCp(x.rc))`]
  "\n"/(s1;s2)
}
doXAV:{
  nxt:?[xt~"B";"I";xt]
  xct:?[xt~"B";"b2i";xt~"I";"int64";xt~"F";"float64";xt]
  sub[("{OPE}";escp op;"{OP}";op;"{OO}";o;"{XT}";nxt;"{XCT}";xct)]"\n"_`
  case *AV:
          if x.Len() != yv.Len() {
                  return Panicf("x{OPE}y : length mismatch: %d vs %d", x.Len(), yv.Len())
          }
          r := yv.reuse()
          for i := range r.Slice {
                  ri := {OO}{XT}V({XCT}(x.At(i)), yv.At(i))
                  if ri.IsPanic() {
                          return ri
                  }
                  r.Slice[i] = ri
          }
          return NewV(r)
  default:
          return panicTypeElt("x{OP}y", "y", y)
  }
}
`
}

say package
genOp["equal";"="]
genOp["lesser";"<"]
genOp["greater";">"]
genOp["add";"+"]
genOp["subtract";"-"]
genOp["multiply";"*"]
genOp["divide";"%"]
genOp["minimum";"&"]
genOp["maximum";"|"]
genOp["modulus";"!"]
